// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package enginev1

import (
	_ "cosmossdk.io/api/ethereum/eth/ext"
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var _ protoreflect.List = (*_ExecutionPayload_14_list)(nil)

type _ExecutionPayload_14_list struct {
	list *[][]byte
}

func (x *_ExecutionPayload_14_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayload_14_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_ExecutionPayload_14_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayload_14_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayload_14_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ExecutionPayload at list field Transactions as it is not of Message kind"))
}

func (x *_ExecutionPayload_14_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayload_14_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_ExecutionPayload_14_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExecutionPayload                  protoreflect.MessageDescriptor
	fd_ExecutionPayload_parent_hash      protoreflect.FieldDescriptor
	fd_ExecutionPayload_fee_recipient    protoreflect.FieldDescriptor
	fd_ExecutionPayload_state_root       protoreflect.FieldDescriptor
	fd_ExecutionPayload_receipts_root    protoreflect.FieldDescriptor
	fd_ExecutionPayload_logs_bloom       protoreflect.FieldDescriptor
	fd_ExecutionPayload_prev_randao      protoreflect.FieldDescriptor
	fd_ExecutionPayload_block_number     protoreflect.FieldDescriptor
	fd_ExecutionPayload_gas_limit        protoreflect.FieldDescriptor
	fd_ExecutionPayload_gas_used         protoreflect.FieldDescriptor
	fd_ExecutionPayload_timestamp        protoreflect.FieldDescriptor
	fd_ExecutionPayload_extra_data       protoreflect.FieldDescriptor
	fd_ExecutionPayload_base_fee_per_gas protoreflect.FieldDescriptor
	fd_ExecutionPayload_block_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayload_transactions     protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayload = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayload")
	fd_ExecutionPayload_parent_hash = md_ExecutionPayload.Fields().ByName("parent_hash")
	fd_ExecutionPayload_fee_recipient = md_ExecutionPayload.Fields().ByName("fee_recipient")
	fd_ExecutionPayload_state_root = md_ExecutionPayload.Fields().ByName("state_root")
	fd_ExecutionPayload_receipts_root = md_ExecutionPayload.Fields().ByName("receipts_root")
	fd_ExecutionPayload_logs_bloom = md_ExecutionPayload.Fields().ByName("logs_bloom")
	fd_ExecutionPayload_prev_randao = md_ExecutionPayload.Fields().ByName("prev_randao")
	fd_ExecutionPayload_block_number = md_ExecutionPayload.Fields().ByName("block_number")
	fd_ExecutionPayload_gas_limit = md_ExecutionPayload.Fields().ByName("gas_limit")
	fd_ExecutionPayload_gas_used = md_ExecutionPayload.Fields().ByName("gas_used")
	fd_ExecutionPayload_timestamp = md_ExecutionPayload.Fields().ByName("timestamp")
	fd_ExecutionPayload_extra_data = md_ExecutionPayload.Fields().ByName("extra_data")
	fd_ExecutionPayload_base_fee_per_gas = md_ExecutionPayload.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayload_block_hash = md_ExecutionPayload.Fields().ByName("block_hash")
	fd_ExecutionPayload_transactions = md_ExecutionPayload.Fields().ByName("transactions")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayload)(nil)

type fastReflection_ExecutionPayload ExecutionPayload

func (x *ExecutionPayload) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayload)(x)
}

func (x *ExecutionPayload) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayload_messageType fastReflection_ExecutionPayload_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayload_messageType{}

type fastReflection_ExecutionPayload_messageType struct{}

func (x fastReflection_ExecutionPayload_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayload)(nil)
}
func (x fastReflection_ExecutionPayload_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayload)
}
func (x fastReflection_ExecutionPayload_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayload
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayload) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayload
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayload) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayload_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayload) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayload)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayload) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayload)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayload) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayload_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayload_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayload_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayload_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayload_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayload_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayload_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayload_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayload_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayload_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayload_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayload_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayload_block_hash, value) {
			return
		}
	}
	if len(x.Transactions) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayload_14_list{list: &x.Transactions})
		if !f(fd_ExecutionPayload_transactions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayload) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		return len(x.Transactions) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayload) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		x.Transactions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayload) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		if len(x.Transactions) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayload_14_list{})
		}
		listValue := &_ExecutionPayload_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayload) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		lv := value.List()
		clv := lv.(*_ExecutionPayload_14_list)
		x.Transactions = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayload) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		if x.Transactions == nil {
			x.Transactions = [][]byte{}
		}
		value := &_ExecutionPayload_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayload is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayload) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayload.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayload.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayload.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayload.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayload.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayload.transactions":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_ExecutionPayload_14_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayload"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayload does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayload) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayload", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayload) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayload) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayload) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayload) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayload)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Transactions) > 0 {
			for _, b := range x.Transactions {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayload)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Transactions) > 0 {
			for iNdEx := len(x.Transactions) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Transactions[iNdEx])
				copy(dAtA[i:], x.Transactions[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Transactions[iNdEx])))
				i--
				dAtA[i] = 0x72
			}
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayload)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayload: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayload: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Transactions = append(x.Transactions, make([]byte, postIndex-iNdEx))
				copy(x.Transactions[len(x.Transactions)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ExecutionPayloadBodyV1_1_list)(nil)

type _ExecutionPayloadBodyV1_1_list struct {
	list *[][]byte
}

func (x *_ExecutionPayloadBodyV1_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadBodyV1_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_ExecutionPayloadBodyV1_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadBodyV1_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadBodyV1_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ExecutionPayloadBodyV1 at list field Transactions as it is not of Message kind"))
}

func (x *_ExecutionPayloadBodyV1_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadBodyV1_1_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_ExecutionPayloadBodyV1_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ExecutionPayloadBodyV1_2_list)(nil)

type _ExecutionPayloadBodyV1_2_list struct {
	list *[]*Withdrawal
}

func (x *_ExecutionPayloadBodyV1_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadBodyV1_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ExecutionPayloadBodyV1_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadBodyV1_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadBodyV1_2_list) AppendMutable() protoreflect.Value {
	v := new(Withdrawal)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadBodyV1_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadBodyV1_2_list) NewElement() protoreflect.Value {
	v := new(Withdrawal)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadBodyV1_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExecutionPayloadBodyV1              protoreflect.MessageDescriptor
	fd_ExecutionPayloadBodyV1_transactions protoreflect.FieldDescriptor
	fd_ExecutionPayloadBodyV1_withdrawals  protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadBodyV1 = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadBodyV1")
	fd_ExecutionPayloadBodyV1_transactions = md_ExecutionPayloadBodyV1.Fields().ByName("transactions")
	fd_ExecutionPayloadBodyV1_withdrawals = md_ExecutionPayloadBodyV1.Fields().ByName("withdrawals")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadBodyV1)(nil)

type fastReflection_ExecutionPayloadBodyV1 ExecutionPayloadBodyV1

func (x *ExecutionPayloadBodyV1) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadBodyV1)(x)
}

func (x *ExecutionPayloadBodyV1) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadBodyV1_messageType fastReflection_ExecutionPayloadBodyV1_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadBodyV1_messageType{}

type fastReflection_ExecutionPayloadBodyV1_messageType struct{}

func (x fastReflection_ExecutionPayloadBodyV1_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadBodyV1)(nil)
}
func (x fastReflection_ExecutionPayloadBodyV1_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadBodyV1)
}
func (x fastReflection_ExecutionPayloadBodyV1_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadBodyV1
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadBodyV1) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadBodyV1
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadBodyV1) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadBodyV1_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadBodyV1) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadBodyV1)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadBodyV1) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadBodyV1)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadBodyV1) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Transactions) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_1_list{list: &x.Transactions})
		if !f(fd_ExecutionPayloadBodyV1_transactions, value) {
			return
		}
	}
	if len(x.Withdrawals) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_2_list{list: &x.Withdrawals})
		if !f(fd_ExecutionPayloadBodyV1_withdrawals, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadBodyV1) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		return len(x.Transactions) != 0
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		return len(x.Withdrawals) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadBodyV1) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		x.Transactions = nil
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		x.Withdrawals = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadBodyV1) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		if len(x.Transactions) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_1_list{})
		}
		listValue := &_ExecutionPayloadBodyV1_1_list{list: &x.Transactions}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		if len(x.Withdrawals) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_2_list{})
		}
		listValue := &_ExecutionPayloadBodyV1_2_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadBodyV1) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadBodyV1_1_list)
		x.Transactions = *clv.list
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadBodyV1_2_list)
		x.Withdrawals = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadBodyV1) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		if x.Transactions == nil {
			x.Transactions = [][]byte{}
		}
		value := &_ExecutionPayloadBodyV1_1_list{list: &x.Transactions}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		if x.Withdrawals == nil {
			x.Withdrawals = []*Withdrawal{}
		}
		value := &_ExecutionPayloadBodyV1_2_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadBodyV1) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.transactions":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_1_list{list: &list})
	case "ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals":
		list := []*Withdrawal{}
		return protoreflect.ValueOfList(&_ExecutionPayloadBodyV1_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadBodyV1"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadBodyV1 does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadBodyV1) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadBodyV1", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadBodyV1) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadBodyV1) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadBodyV1) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadBodyV1) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadBodyV1)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Transactions) > 0 {
			for _, b := range x.Transactions {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Withdrawals) > 0 {
			for _, e := range x.Withdrawals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadBodyV1)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Withdrawals) > 0 {
			for iNdEx := len(x.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Withdrawals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Transactions) > 0 {
			for iNdEx := len(x.Transactions) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Transactions[iNdEx])
				copy(dAtA[i:], x.Transactions[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Transactions[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadBodyV1)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadBodyV1: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadBodyV1: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Transactions = append(x.Transactions, make([]byte, postIndex-iNdEx))
				copy(x.Transactions[len(x.Transactions)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Withdrawals = append(x.Withdrawals, &Withdrawal{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Withdrawals[len(x.Withdrawals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ExecutionPayloadCapella_14_list)(nil)

type _ExecutionPayloadCapella_14_list struct {
	list *[][]byte
}

func (x *_ExecutionPayloadCapella_14_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadCapella_14_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_ExecutionPayloadCapella_14_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadCapella_14_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadCapella_14_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ExecutionPayloadCapella at list field Transactions as it is not of Message kind"))
}

func (x *_ExecutionPayloadCapella_14_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadCapella_14_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_ExecutionPayloadCapella_14_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ExecutionPayloadCapella_15_list)(nil)

type _ExecutionPayloadCapella_15_list struct {
	list *[]*Withdrawal
}

func (x *_ExecutionPayloadCapella_15_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadCapella_15_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ExecutionPayloadCapella_15_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadCapella_15_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadCapella_15_list) AppendMutable() protoreflect.Value {
	v := new(Withdrawal)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadCapella_15_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadCapella_15_list) NewElement() protoreflect.Value {
	v := new(Withdrawal)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadCapella_15_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExecutionPayloadCapella                  protoreflect.MessageDescriptor
	fd_ExecutionPayloadCapella_parent_hash      protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_fee_recipient    protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_state_root       protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_receipts_root    protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_logs_bloom       protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_prev_randao      protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_block_number     protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_gas_limit        protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_gas_used         protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_timestamp        protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_extra_data       protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_base_fee_per_gas protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_block_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_transactions     protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapella_withdrawals      protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadCapella = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadCapella")
	fd_ExecutionPayloadCapella_parent_hash = md_ExecutionPayloadCapella.Fields().ByName("parent_hash")
	fd_ExecutionPayloadCapella_fee_recipient = md_ExecutionPayloadCapella.Fields().ByName("fee_recipient")
	fd_ExecutionPayloadCapella_state_root = md_ExecutionPayloadCapella.Fields().ByName("state_root")
	fd_ExecutionPayloadCapella_receipts_root = md_ExecutionPayloadCapella.Fields().ByName("receipts_root")
	fd_ExecutionPayloadCapella_logs_bloom = md_ExecutionPayloadCapella.Fields().ByName("logs_bloom")
	fd_ExecutionPayloadCapella_prev_randao = md_ExecutionPayloadCapella.Fields().ByName("prev_randao")
	fd_ExecutionPayloadCapella_block_number = md_ExecutionPayloadCapella.Fields().ByName("block_number")
	fd_ExecutionPayloadCapella_gas_limit = md_ExecutionPayloadCapella.Fields().ByName("gas_limit")
	fd_ExecutionPayloadCapella_gas_used = md_ExecutionPayloadCapella.Fields().ByName("gas_used")
	fd_ExecutionPayloadCapella_timestamp = md_ExecutionPayloadCapella.Fields().ByName("timestamp")
	fd_ExecutionPayloadCapella_extra_data = md_ExecutionPayloadCapella.Fields().ByName("extra_data")
	fd_ExecutionPayloadCapella_base_fee_per_gas = md_ExecutionPayloadCapella.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayloadCapella_block_hash = md_ExecutionPayloadCapella.Fields().ByName("block_hash")
	fd_ExecutionPayloadCapella_transactions = md_ExecutionPayloadCapella.Fields().ByName("transactions")
	fd_ExecutionPayloadCapella_withdrawals = md_ExecutionPayloadCapella.Fields().ByName("withdrawals")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadCapella)(nil)

type fastReflection_ExecutionPayloadCapella ExecutionPayloadCapella

func (x *ExecutionPayloadCapella) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadCapella)(x)
}

func (x *ExecutionPayloadCapella) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadCapella_messageType fastReflection_ExecutionPayloadCapella_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadCapella_messageType{}

type fastReflection_ExecutionPayloadCapella_messageType struct{}

func (x fastReflection_ExecutionPayloadCapella_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadCapella)(nil)
}
func (x fastReflection_ExecutionPayloadCapella_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadCapella)
}
func (x fastReflection_ExecutionPayloadCapella_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadCapella
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadCapella) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadCapella
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadCapella) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadCapella_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadCapella) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadCapella)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadCapella) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadCapella)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadCapella) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayloadCapella_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayloadCapella_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayloadCapella_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayloadCapella_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayloadCapella_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayloadCapella_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayloadCapella_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayloadCapella_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayloadCapella_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayloadCapella_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayloadCapella_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayloadCapella_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayloadCapella_block_hash, value) {
			return
		}
	}
	if len(x.Transactions) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadCapella_14_list{list: &x.Transactions})
		if !f(fd_ExecutionPayloadCapella_transactions, value) {
			return
		}
	}
	if len(x.Withdrawals) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadCapella_15_list{list: &x.Withdrawals})
		if !f(fd_ExecutionPayloadCapella_withdrawals, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadCapella) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		return len(x.Transactions) != 0
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		return len(x.Withdrawals) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapella) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		x.Transactions = nil
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		x.Withdrawals = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadCapella) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		if len(x.Transactions) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadCapella_14_list{})
		}
		listValue := &_ExecutionPayloadCapella_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		if len(x.Withdrawals) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadCapella_15_list{})
		}
		listValue := &_ExecutionPayloadCapella_15_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapella) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadCapella_14_list)
		x.Transactions = *clv.list
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadCapella_15_list)
		x.Withdrawals = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapella) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		if x.Transactions == nil {
			x.Transactions = [][]byte{}
		}
		value := &_ExecutionPayloadCapella_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		if x.Withdrawals == nil {
			x.Withdrawals = []*Withdrawal{}
		}
		value := &_ExecutionPayloadCapella_15_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayloadCapella is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadCapella) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapella.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadCapella.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadCapella.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadCapella.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadCapella.transactions":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_ExecutionPayloadCapella_14_list{list: &list})
	case "ethereum.engine.v1.ExecutionPayloadCapella.withdrawals":
		list := []*Withdrawal{}
		return protoreflect.ValueOfList(&_ExecutionPayloadCapella_15_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapella does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadCapella) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadCapella", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadCapella) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapella) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadCapella) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadCapella) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadCapella)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Transactions) > 0 {
			for _, b := range x.Transactions {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Withdrawals) > 0 {
			for _, e := range x.Withdrawals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadCapella)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Withdrawals) > 0 {
			for iNdEx := len(x.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Withdrawals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x7a
			}
		}
		if len(x.Transactions) > 0 {
			for iNdEx := len(x.Transactions) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Transactions[iNdEx])
				copy(dAtA[i:], x.Transactions[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Transactions[iNdEx])))
				i--
				dAtA[i] = 0x72
			}
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadCapella)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadCapella: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadCapella: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Transactions = append(x.Transactions, make([]byte, postIndex-iNdEx))
				copy(x.Transactions[len(x.Transactions)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 15:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Withdrawals = append(x.Withdrawals, &Withdrawal{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Withdrawals[len(x.Withdrawals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ExecutionPayloadDeneb_14_list)(nil)

type _ExecutionPayloadDeneb_14_list struct {
	list *[][]byte
}

func (x *_ExecutionPayloadDeneb_14_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadDeneb_14_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_ExecutionPayloadDeneb_14_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadDeneb_14_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadDeneb_14_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ExecutionPayloadDeneb at list field Transactions as it is not of Message kind"))
}

func (x *_ExecutionPayloadDeneb_14_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadDeneb_14_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_ExecutionPayloadDeneb_14_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ExecutionPayloadDeneb_15_list)(nil)

type _ExecutionPayloadDeneb_15_list struct {
	list *[]*Withdrawal
}

func (x *_ExecutionPayloadDeneb_15_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExecutionPayloadDeneb_15_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ExecutionPayloadDeneb_15_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	(*x.list)[i] = concreteValue
}

func (x *_ExecutionPayloadDeneb_15_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExecutionPayloadDeneb_15_list) AppendMutable() protoreflect.Value {
	v := new(Withdrawal)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadDeneb_15_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ExecutionPayloadDeneb_15_list) NewElement() protoreflect.Value {
	v := new(Withdrawal)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ExecutionPayloadDeneb_15_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExecutionPayloadDeneb                  protoreflect.MessageDescriptor
	fd_ExecutionPayloadDeneb_parent_hash      protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_fee_recipient    protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_state_root       protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_receipts_root    protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_logs_bloom       protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_prev_randao      protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_block_number     protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_gas_limit        protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_gas_used         protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_timestamp        protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_extra_data       protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_base_fee_per_gas protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_block_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_transactions     protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_withdrawals      protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_blob_gas_used    protoreflect.FieldDescriptor
	fd_ExecutionPayloadDeneb_excess_blob_gas  protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadDeneb = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadDeneb")
	fd_ExecutionPayloadDeneb_parent_hash = md_ExecutionPayloadDeneb.Fields().ByName("parent_hash")
	fd_ExecutionPayloadDeneb_fee_recipient = md_ExecutionPayloadDeneb.Fields().ByName("fee_recipient")
	fd_ExecutionPayloadDeneb_state_root = md_ExecutionPayloadDeneb.Fields().ByName("state_root")
	fd_ExecutionPayloadDeneb_receipts_root = md_ExecutionPayloadDeneb.Fields().ByName("receipts_root")
	fd_ExecutionPayloadDeneb_logs_bloom = md_ExecutionPayloadDeneb.Fields().ByName("logs_bloom")
	fd_ExecutionPayloadDeneb_prev_randao = md_ExecutionPayloadDeneb.Fields().ByName("prev_randao")
	fd_ExecutionPayloadDeneb_block_number = md_ExecutionPayloadDeneb.Fields().ByName("block_number")
	fd_ExecutionPayloadDeneb_gas_limit = md_ExecutionPayloadDeneb.Fields().ByName("gas_limit")
	fd_ExecutionPayloadDeneb_gas_used = md_ExecutionPayloadDeneb.Fields().ByName("gas_used")
	fd_ExecutionPayloadDeneb_timestamp = md_ExecutionPayloadDeneb.Fields().ByName("timestamp")
	fd_ExecutionPayloadDeneb_extra_data = md_ExecutionPayloadDeneb.Fields().ByName("extra_data")
	fd_ExecutionPayloadDeneb_base_fee_per_gas = md_ExecutionPayloadDeneb.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayloadDeneb_block_hash = md_ExecutionPayloadDeneb.Fields().ByName("block_hash")
	fd_ExecutionPayloadDeneb_transactions = md_ExecutionPayloadDeneb.Fields().ByName("transactions")
	fd_ExecutionPayloadDeneb_withdrawals = md_ExecutionPayloadDeneb.Fields().ByName("withdrawals")
	fd_ExecutionPayloadDeneb_blob_gas_used = md_ExecutionPayloadDeneb.Fields().ByName("blob_gas_used")
	fd_ExecutionPayloadDeneb_excess_blob_gas = md_ExecutionPayloadDeneb.Fields().ByName("excess_blob_gas")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadDeneb)(nil)

type fastReflection_ExecutionPayloadDeneb ExecutionPayloadDeneb

func (x *ExecutionPayloadDeneb) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadDeneb)(x)
}

func (x *ExecutionPayloadDeneb) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadDeneb_messageType fastReflection_ExecutionPayloadDeneb_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadDeneb_messageType{}

type fastReflection_ExecutionPayloadDeneb_messageType struct{}

func (x fastReflection_ExecutionPayloadDeneb_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadDeneb)(nil)
}
func (x fastReflection_ExecutionPayloadDeneb_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadDeneb)
}
func (x fastReflection_ExecutionPayloadDeneb_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadDeneb
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadDeneb) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadDeneb
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadDeneb) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadDeneb_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadDeneb) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadDeneb)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadDeneb) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadDeneb)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadDeneb) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayloadDeneb_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayloadDeneb_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayloadDeneb_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayloadDeneb_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayloadDeneb_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayloadDeneb_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayloadDeneb_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayloadDeneb_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayloadDeneb_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayloadDeneb_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayloadDeneb_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayloadDeneb_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayloadDeneb_block_hash, value) {
			return
		}
	}
	if len(x.Transactions) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadDeneb_14_list{list: &x.Transactions})
		if !f(fd_ExecutionPayloadDeneb_transactions, value) {
			return
		}
	}
	if len(x.Withdrawals) != 0 {
		value := protoreflect.ValueOfList(&_ExecutionPayloadDeneb_15_list{list: &x.Withdrawals})
		if !f(fd_ExecutionPayloadDeneb_withdrawals, value) {
			return
		}
	}
	if x.BlobGasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlobGasUsed)
		if !f(fd_ExecutionPayloadDeneb_blob_gas_used, value) {
			return
		}
	}
	if x.ExcessBlobGas != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ExcessBlobGas)
		if !f(fd_ExecutionPayloadDeneb_excess_blob_gas, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadDeneb) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		return len(x.Transactions) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		return len(x.Withdrawals) != 0
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		return x.BlobGasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		return x.ExcessBlobGas != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDeneb) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		x.Transactions = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		x.Withdrawals = nil
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		x.BlobGasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		x.ExcessBlobGas = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadDeneb) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		if len(x.Transactions) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadDeneb_14_list{})
		}
		listValue := &_ExecutionPayloadDeneb_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		if len(x.Withdrawals) == 0 {
			return protoreflect.ValueOfList(&_ExecutionPayloadDeneb_15_list{})
		}
		listValue := &_ExecutionPayloadDeneb_15_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		value := x.BlobGasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		value := x.ExcessBlobGas
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDeneb) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadDeneb_14_list)
		x.Transactions = *clv.list
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		lv := value.List()
		clv := lv.(*_ExecutionPayloadDeneb_15_list)
		x.Withdrawals = *clv.list
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		x.BlobGasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		x.ExcessBlobGas = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDeneb) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		if x.Transactions == nil {
			x.Transactions = [][]byte{}
		}
		value := &_ExecutionPayloadDeneb_14_list{list: &x.Transactions}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		if x.Withdrawals == nil {
			x.Withdrawals = []*Withdrawal{}
		}
		value := &_ExecutionPayloadDeneb_15_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		panic(fmt.Errorf("field blob_gas_used of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		panic(fmt.Errorf("field excess_blob_gas of message ethereum.engine.v1.ExecutionPayloadDeneb is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadDeneb) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDeneb.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDeneb.transactions":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_ExecutionPayloadDeneb_14_list{list: &list})
	case "ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals":
		list := []*Withdrawal{}
		return protoreflect.ValueOfList(&_ExecutionPayloadDeneb_15_list{list: &list})
	case "ethereum.engine.v1.ExecutionPayloadDeneb.blob_gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadDeneb.excess_blob_gas":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDeneb does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadDeneb) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadDeneb", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadDeneb) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDeneb) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadDeneb) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadDeneb) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadDeneb)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Transactions) > 0 {
			for _, b := range x.Transactions {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Withdrawals) > 0 {
			for _, e := range x.Withdrawals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.BlobGasUsed != 0 {
			n += 2 + runtime.Sov(uint64(x.BlobGasUsed))
		}
		if x.ExcessBlobGas != 0 {
			n += 2 + runtime.Sov(uint64(x.ExcessBlobGas))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadDeneb)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExcessBlobGas != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ExcessBlobGas))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x88
		}
		if x.BlobGasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlobGasUsed))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
		if len(x.Withdrawals) > 0 {
			for iNdEx := len(x.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Withdrawals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x7a
			}
		}
		if len(x.Transactions) > 0 {
			for iNdEx := len(x.Transactions) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Transactions[iNdEx])
				copy(dAtA[i:], x.Transactions[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Transactions[iNdEx])))
				i--
				dAtA[i] = 0x72
			}
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadDeneb)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadDeneb: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadDeneb: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Transactions = append(x.Transactions, make([]byte, postIndex-iNdEx))
				copy(x.Transactions[len(x.Transactions)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 15:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Withdrawals = append(x.Withdrawals, &Withdrawal{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Withdrawals[len(x.Withdrawals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 16:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlobGasUsed", wireType)
				}
				x.BlobGasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlobGasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 17:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExcessBlobGas", wireType)
				}
				x.ExcessBlobGas = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ExcessBlobGas |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ExecutionPayloadCapellaWithValue         protoreflect.MessageDescriptor
	fd_ExecutionPayloadCapellaWithValue_payload protoreflect.FieldDescriptor
	fd_ExecutionPayloadCapellaWithValue_value   protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadCapellaWithValue = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadCapellaWithValue")
	fd_ExecutionPayloadCapellaWithValue_payload = md_ExecutionPayloadCapellaWithValue.Fields().ByName("payload")
	fd_ExecutionPayloadCapellaWithValue_value = md_ExecutionPayloadCapellaWithValue.Fields().ByName("value")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadCapellaWithValue)(nil)

type fastReflection_ExecutionPayloadCapellaWithValue ExecutionPayloadCapellaWithValue

func (x *ExecutionPayloadCapellaWithValue) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadCapellaWithValue)(x)
}

func (x *ExecutionPayloadCapellaWithValue) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadCapellaWithValue_messageType fastReflection_ExecutionPayloadCapellaWithValue_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadCapellaWithValue_messageType{}

type fastReflection_ExecutionPayloadCapellaWithValue_messageType struct{}

func (x fastReflection_ExecutionPayloadCapellaWithValue_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadCapellaWithValue)(nil)
}
func (x fastReflection_ExecutionPayloadCapellaWithValue_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadCapellaWithValue)
}
func (x fastReflection_ExecutionPayloadCapellaWithValue_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadCapellaWithValue
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadCapellaWithValue
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadCapellaWithValue_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadCapellaWithValue)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadCapellaWithValue)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Payload != nil {
		value := protoreflect.ValueOfMessage(x.Payload.ProtoReflect())
		if !f(fd_ExecutionPayloadCapellaWithValue_payload, value) {
			return
		}
	}
	if len(x.Value) != 0 {
		value := protoreflect.ValueOfBytes(x.Value)
		if !f(fd_ExecutionPayloadCapellaWithValue_value, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		return x.Payload != nil
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		return len(x.Value) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		x.Payload = nil
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		x.Value = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		value := x.Payload
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		value := x.Value
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		x.Payload = value.Message().Interface().(*ExecutionPayloadCapella)
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		x.Value = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		if x.Payload == nil {
			x.Payload = new(ExecutionPayloadCapella)
		}
		return protoreflect.ValueOfMessage(x.Payload.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		panic(fmt.Errorf("field value of message ethereum.engine.v1.ExecutionPayloadCapellaWithValue is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload":
		m := new(ExecutionPayloadCapella)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadCapellaWithValue.value":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadCapellaWithValue"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadCapellaWithValue does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadCapellaWithValue", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadCapellaWithValue) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadCapellaWithValue)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Payload != nil {
			l = options.Size(x.Payload)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadCapellaWithValue)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if x.Payload != nil {
			encoded, err := options.Marshal(x.Payload)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadCapellaWithValue)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadCapellaWithValue: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadCapellaWithValue: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Payload == nil {
					x.Payload = &ExecutionPayloadCapella{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Payload); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = append(x.Value[:0], dAtA[iNdEx:postIndex]...)
				if x.Value == nil {
					x.Value = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ExecutionPayloadDenebWithValueAndBlobsBundle                         protoreflect.MessageDescriptor
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_payload                 protoreflect.FieldDescriptor
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_value                   protoreflect.FieldDescriptor
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_blobs_bundle            protoreflect.FieldDescriptor
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_should_override_builder protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadDenebWithValueAndBlobsBundle = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadDenebWithValueAndBlobsBundle")
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_payload = md_ExecutionPayloadDenebWithValueAndBlobsBundle.Fields().ByName("payload")
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_value = md_ExecutionPayloadDenebWithValueAndBlobsBundle.Fields().ByName("value")
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_blobs_bundle = md_ExecutionPayloadDenebWithValueAndBlobsBundle.Fields().ByName("blobs_bundle")
	fd_ExecutionPayloadDenebWithValueAndBlobsBundle_should_override_builder = md_ExecutionPayloadDenebWithValueAndBlobsBundle.Fields().ByName("should_override_builder")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle)(nil)

type fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle ExecutionPayloadDenebWithValueAndBlobsBundle

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle)(x)
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType{}

type fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType struct{}

func (x fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle)(nil)
}
func (x fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle)
}
func (x fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadDenebWithValueAndBlobsBundle
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadDenebWithValueAndBlobsBundle
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadDenebWithValueAndBlobsBundle)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Payload != nil {
		value := protoreflect.ValueOfMessage(x.Payload.ProtoReflect())
		if !f(fd_ExecutionPayloadDenebWithValueAndBlobsBundle_payload, value) {
			return
		}
	}
	if len(x.Value) != 0 {
		value := protoreflect.ValueOfBytes(x.Value)
		if !f(fd_ExecutionPayloadDenebWithValueAndBlobsBundle_value, value) {
			return
		}
	}
	if x.BlobsBundle != nil {
		value := protoreflect.ValueOfMessage(x.BlobsBundle.ProtoReflect())
		if !f(fd_ExecutionPayloadDenebWithValueAndBlobsBundle_blobs_bundle, value) {
			return
		}
	}
	if x.ShouldOverrideBuilder != false {
		value := protoreflect.ValueOfBool(x.ShouldOverrideBuilder)
		if !f(fd_ExecutionPayloadDenebWithValueAndBlobsBundle_should_override_builder, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		return x.Payload != nil
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		return len(x.Value) != 0
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		return x.BlobsBundle != nil
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		return x.ShouldOverrideBuilder != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		x.Payload = nil
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		x.Value = nil
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		x.BlobsBundle = nil
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		x.ShouldOverrideBuilder = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		value := x.Payload
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		value := x.Value
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		value := x.BlobsBundle
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		value := x.ShouldOverrideBuilder
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		x.Payload = value.Message().Interface().(*ExecutionPayloadDeneb)
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		x.Value = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		x.BlobsBundle = value.Message().Interface().(*BlobsBundle)
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		x.ShouldOverrideBuilder = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		if x.Payload == nil {
			x.Payload = new(ExecutionPayloadDeneb)
		}
		return protoreflect.ValueOfMessage(x.Payload.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		if x.BlobsBundle == nil {
			x.BlobsBundle = new(BlobsBundle)
		}
		return protoreflect.ValueOfMessage(x.BlobsBundle.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		panic(fmt.Errorf("field value of message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		panic(fmt.Errorf("field should_override_builder of message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload":
		m := new(ExecutionPayloadDeneb)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.value":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle":
		m := new(BlobsBundle)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.should_override_builder":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadDenebWithValueAndBlobsBundle) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadDenebWithValueAndBlobsBundle)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Payload != nil {
			l = options.Size(x.Payload)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlobsBundle != nil {
			l = options.Size(x.BlobsBundle)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ShouldOverrideBuilder {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadDenebWithValueAndBlobsBundle)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ShouldOverrideBuilder {
			i--
			if x.ShouldOverrideBuilder {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.BlobsBundle != nil {
			encoded, err := options.Marshal(x.BlobsBundle)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if x.Payload != nil {
			encoded, err := options.Marshal(x.Payload)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadDenebWithValueAndBlobsBundle)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadDenebWithValueAndBlobsBundle: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadDenebWithValueAndBlobsBundle: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Payload == nil {
					x.Payload = &ExecutionPayloadDeneb{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Payload); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = append(x.Value[:0], dAtA[iNdEx:postIndex]...)
				if x.Value == nil {
					x.Value = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlobsBundle", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.BlobsBundle == nil {
					x.BlobsBundle = &BlobsBundle{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.BlobsBundle); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ShouldOverrideBuilder", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ShouldOverrideBuilder = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ExecutionPayloadHeader                   protoreflect.MessageDescriptor
	fd_ExecutionPayloadHeader_parent_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_fee_recipient     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_state_root        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_receipts_root     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_logs_bloom        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_prev_randao       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_block_number      protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_gas_limit         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_gas_used          protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_timestamp         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_extra_data        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_base_fee_per_gas  protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_block_hash        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeader_transactions_root protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadHeader = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadHeader")
	fd_ExecutionPayloadHeader_parent_hash = md_ExecutionPayloadHeader.Fields().ByName("parent_hash")
	fd_ExecutionPayloadHeader_fee_recipient = md_ExecutionPayloadHeader.Fields().ByName("fee_recipient")
	fd_ExecutionPayloadHeader_state_root = md_ExecutionPayloadHeader.Fields().ByName("state_root")
	fd_ExecutionPayloadHeader_receipts_root = md_ExecutionPayloadHeader.Fields().ByName("receipts_root")
	fd_ExecutionPayloadHeader_logs_bloom = md_ExecutionPayloadHeader.Fields().ByName("logs_bloom")
	fd_ExecutionPayloadHeader_prev_randao = md_ExecutionPayloadHeader.Fields().ByName("prev_randao")
	fd_ExecutionPayloadHeader_block_number = md_ExecutionPayloadHeader.Fields().ByName("block_number")
	fd_ExecutionPayloadHeader_gas_limit = md_ExecutionPayloadHeader.Fields().ByName("gas_limit")
	fd_ExecutionPayloadHeader_gas_used = md_ExecutionPayloadHeader.Fields().ByName("gas_used")
	fd_ExecutionPayloadHeader_timestamp = md_ExecutionPayloadHeader.Fields().ByName("timestamp")
	fd_ExecutionPayloadHeader_extra_data = md_ExecutionPayloadHeader.Fields().ByName("extra_data")
	fd_ExecutionPayloadHeader_base_fee_per_gas = md_ExecutionPayloadHeader.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayloadHeader_block_hash = md_ExecutionPayloadHeader.Fields().ByName("block_hash")
	fd_ExecutionPayloadHeader_transactions_root = md_ExecutionPayloadHeader.Fields().ByName("transactions_root")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadHeader)(nil)

type fastReflection_ExecutionPayloadHeader ExecutionPayloadHeader

func (x *ExecutionPayloadHeader) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeader)(x)
}

func (x *ExecutionPayloadHeader) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadHeader_messageType fastReflection_ExecutionPayloadHeader_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadHeader_messageType{}

type fastReflection_ExecutionPayloadHeader_messageType struct{}

func (x fastReflection_ExecutionPayloadHeader_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeader)(nil)
}
func (x fastReflection_ExecutionPayloadHeader_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeader)
}
func (x fastReflection_ExecutionPayloadHeader_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeader
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadHeader) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeader
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadHeader) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadHeader_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadHeader) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeader)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadHeader) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadHeader)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadHeader) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayloadHeader_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayloadHeader_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayloadHeader_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayloadHeader_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayloadHeader_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayloadHeader_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayloadHeader_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayloadHeader_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayloadHeader_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayloadHeader_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayloadHeader_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayloadHeader_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayloadHeader_block_hash, value) {
			return
		}
	}
	if len(x.TransactionsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.TransactionsRoot)
		if !f(fd_ExecutionPayloadHeader_transactions_root, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadHeader) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		return len(x.TransactionsRoot) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeader) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		x.TransactionsRoot = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadHeader) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		value := x.TransactionsRoot
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeader) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		x.TransactionsRoot = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeader) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		panic(fmt.Errorf("field transactions_root of message ethereum.engine.v1.ExecutionPayloadHeader is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadHeader) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeader.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeader.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeader.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeader.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeader.transactions_root":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeader"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeader does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadHeader) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadHeader", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadHeader) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeader) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadHeader) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadHeader) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadHeader)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TransactionsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeader)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TransactionsRoot) > 0 {
			i -= len(x.TransactionsRoot)
			copy(dAtA[i:], x.TransactionsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionsRoot)))
			i--
			dAtA[i] = 0x72
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeader)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeader: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeader: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionsRoot = append(x.TransactionsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.TransactionsRoot == nil {
					x.TransactionsRoot = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ExecutionPayloadHeaderCapella                   protoreflect.MessageDescriptor
	fd_ExecutionPayloadHeaderCapella_parent_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_fee_recipient     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_state_root        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_receipts_root     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_logs_bloom        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_prev_randao       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_block_number      protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_gas_limit         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_gas_used          protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_timestamp         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_extra_data        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_base_fee_per_gas  protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_block_hash        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_transactions_root protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderCapella_withdrawals_root  protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadHeaderCapella = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadHeaderCapella")
	fd_ExecutionPayloadHeaderCapella_parent_hash = md_ExecutionPayloadHeaderCapella.Fields().ByName("parent_hash")
	fd_ExecutionPayloadHeaderCapella_fee_recipient = md_ExecutionPayloadHeaderCapella.Fields().ByName("fee_recipient")
	fd_ExecutionPayloadHeaderCapella_state_root = md_ExecutionPayloadHeaderCapella.Fields().ByName("state_root")
	fd_ExecutionPayloadHeaderCapella_receipts_root = md_ExecutionPayloadHeaderCapella.Fields().ByName("receipts_root")
	fd_ExecutionPayloadHeaderCapella_logs_bloom = md_ExecutionPayloadHeaderCapella.Fields().ByName("logs_bloom")
	fd_ExecutionPayloadHeaderCapella_prev_randao = md_ExecutionPayloadHeaderCapella.Fields().ByName("prev_randao")
	fd_ExecutionPayloadHeaderCapella_block_number = md_ExecutionPayloadHeaderCapella.Fields().ByName("block_number")
	fd_ExecutionPayloadHeaderCapella_gas_limit = md_ExecutionPayloadHeaderCapella.Fields().ByName("gas_limit")
	fd_ExecutionPayloadHeaderCapella_gas_used = md_ExecutionPayloadHeaderCapella.Fields().ByName("gas_used")
	fd_ExecutionPayloadHeaderCapella_timestamp = md_ExecutionPayloadHeaderCapella.Fields().ByName("timestamp")
	fd_ExecutionPayloadHeaderCapella_extra_data = md_ExecutionPayloadHeaderCapella.Fields().ByName("extra_data")
	fd_ExecutionPayloadHeaderCapella_base_fee_per_gas = md_ExecutionPayloadHeaderCapella.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayloadHeaderCapella_block_hash = md_ExecutionPayloadHeaderCapella.Fields().ByName("block_hash")
	fd_ExecutionPayloadHeaderCapella_transactions_root = md_ExecutionPayloadHeaderCapella.Fields().ByName("transactions_root")
	fd_ExecutionPayloadHeaderCapella_withdrawals_root = md_ExecutionPayloadHeaderCapella.Fields().ByName("withdrawals_root")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadHeaderCapella)(nil)

type fastReflection_ExecutionPayloadHeaderCapella ExecutionPayloadHeaderCapella

func (x *ExecutionPayloadHeaderCapella) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeaderCapella)(x)
}

func (x *ExecutionPayloadHeaderCapella) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadHeaderCapella_messageType fastReflection_ExecutionPayloadHeaderCapella_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadHeaderCapella_messageType{}

type fastReflection_ExecutionPayloadHeaderCapella_messageType struct{}

func (x fastReflection_ExecutionPayloadHeaderCapella_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeaderCapella)(nil)
}
func (x fastReflection_ExecutionPayloadHeaderCapella_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeaderCapella)
}
func (x fastReflection_ExecutionPayloadHeaderCapella_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeaderCapella
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeaderCapella
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadHeaderCapella_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadHeaderCapella) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeaderCapella)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadHeaderCapella)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayloadHeaderCapella_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayloadHeaderCapella_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayloadHeaderCapella_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayloadHeaderCapella_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayloadHeaderCapella_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayloadHeaderCapella_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayloadHeaderCapella_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayloadHeaderCapella_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayloadHeaderCapella_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayloadHeaderCapella_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayloadHeaderCapella_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayloadHeaderCapella_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayloadHeaderCapella_block_hash, value) {
			return
		}
	}
	if len(x.TransactionsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.TransactionsRoot)
		if !f(fd_ExecutionPayloadHeaderCapella_transactions_root, value) {
			return
		}
	}
	if len(x.WithdrawalsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.WithdrawalsRoot)
		if !f(fd_ExecutionPayloadHeaderCapella_withdrawals_root, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		return len(x.TransactionsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		return len(x.WithdrawalsRoot) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		x.TransactionsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		x.WithdrawalsRoot = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		value := x.TransactionsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		value := x.WithdrawalsRoot
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		x.TransactionsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		x.WithdrawalsRoot = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderCapella) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		panic(fmt.Errorf("field transactions_root of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		panic(fmt.Errorf("field withdrawals_root of message ethereum.engine.v1.ExecutionPayloadHeaderCapella is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadHeaderCapella) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.transactions_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderCapella.withdrawals_root":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderCapella"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderCapella does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadHeaderCapella) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadHeaderCapella", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadHeaderCapella) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderCapella) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadHeaderCapella) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadHeaderCapella) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadHeaderCapella)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TransactionsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WithdrawalsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeaderCapella)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.WithdrawalsRoot) > 0 {
			i -= len(x.WithdrawalsRoot)
			copy(dAtA[i:], x.WithdrawalsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WithdrawalsRoot)))
			i--
			dAtA[i] = 0x7a
		}
		if len(x.TransactionsRoot) > 0 {
			i -= len(x.TransactionsRoot)
			copy(dAtA[i:], x.TransactionsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionsRoot)))
			i--
			dAtA[i] = 0x72
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeaderCapella)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeaderCapella: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeaderCapella: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionsRoot = append(x.TransactionsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.TransactionsRoot == nil {
					x.TransactionsRoot = []byte{}
				}
				iNdEx = postIndex
			case 15:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WithdrawalsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WithdrawalsRoot = append(x.WithdrawalsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.WithdrawalsRoot == nil {
					x.WithdrawalsRoot = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ExecutionPayloadHeaderDeneb                   protoreflect.MessageDescriptor
	fd_ExecutionPayloadHeaderDeneb_parent_hash       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_fee_recipient     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_state_root        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_receipts_root     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_logs_bloom        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_prev_randao       protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_block_number      protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_gas_limit         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_gas_used          protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_timestamp         protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_extra_data        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_base_fee_per_gas  protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_block_hash        protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_transactions_root protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_withdrawals_root  protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_blob_gas_used     protoreflect.FieldDescriptor
	fd_ExecutionPayloadHeaderDeneb_excess_blob_gas   protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExecutionPayloadHeaderDeneb = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExecutionPayloadHeaderDeneb")
	fd_ExecutionPayloadHeaderDeneb_parent_hash = md_ExecutionPayloadHeaderDeneb.Fields().ByName("parent_hash")
	fd_ExecutionPayloadHeaderDeneb_fee_recipient = md_ExecutionPayloadHeaderDeneb.Fields().ByName("fee_recipient")
	fd_ExecutionPayloadHeaderDeneb_state_root = md_ExecutionPayloadHeaderDeneb.Fields().ByName("state_root")
	fd_ExecutionPayloadHeaderDeneb_receipts_root = md_ExecutionPayloadHeaderDeneb.Fields().ByName("receipts_root")
	fd_ExecutionPayloadHeaderDeneb_logs_bloom = md_ExecutionPayloadHeaderDeneb.Fields().ByName("logs_bloom")
	fd_ExecutionPayloadHeaderDeneb_prev_randao = md_ExecutionPayloadHeaderDeneb.Fields().ByName("prev_randao")
	fd_ExecutionPayloadHeaderDeneb_block_number = md_ExecutionPayloadHeaderDeneb.Fields().ByName("block_number")
	fd_ExecutionPayloadHeaderDeneb_gas_limit = md_ExecutionPayloadHeaderDeneb.Fields().ByName("gas_limit")
	fd_ExecutionPayloadHeaderDeneb_gas_used = md_ExecutionPayloadHeaderDeneb.Fields().ByName("gas_used")
	fd_ExecutionPayloadHeaderDeneb_timestamp = md_ExecutionPayloadHeaderDeneb.Fields().ByName("timestamp")
	fd_ExecutionPayloadHeaderDeneb_extra_data = md_ExecutionPayloadHeaderDeneb.Fields().ByName("extra_data")
	fd_ExecutionPayloadHeaderDeneb_base_fee_per_gas = md_ExecutionPayloadHeaderDeneb.Fields().ByName("base_fee_per_gas")
	fd_ExecutionPayloadHeaderDeneb_block_hash = md_ExecutionPayloadHeaderDeneb.Fields().ByName("block_hash")
	fd_ExecutionPayloadHeaderDeneb_transactions_root = md_ExecutionPayloadHeaderDeneb.Fields().ByName("transactions_root")
	fd_ExecutionPayloadHeaderDeneb_withdrawals_root = md_ExecutionPayloadHeaderDeneb.Fields().ByName("withdrawals_root")
	fd_ExecutionPayloadHeaderDeneb_blob_gas_used = md_ExecutionPayloadHeaderDeneb.Fields().ByName("blob_gas_used")
	fd_ExecutionPayloadHeaderDeneb_excess_blob_gas = md_ExecutionPayloadHeaderDeneb.Fields().ByName("excess_blob_gas")
}

var _ protoreflect.Message = (*fastReflection_ExecutionPayloadHeaderDeneb)(nil)

type fastReflection_ExecutionPayloadHeaderDeneb ExecutionPayloadHeaderDeneb

func (x *ExecutionPayloadHeaderDeneb) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeaderDeneb)(x)
}

func (x *ExecutionPayloadHeaderDeneb) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExecutionPayloadHeaderDeneb_messageType fastReflection_ExecutionPayloadHeaderDeneb_messageType
var _ protoreflect.MessageType = fastReflection_ExecutionPayloadHeaderDeneb_messageType{}

type fastReflection_ExecutionPayloadHeaderDeneb_messageType struct{}

func (x fastReflection_ExecutionPayloadHeaderDeneb_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExecutionPayloadHeaderDeneb)(nil)
}
func (x fastReflection_ExecutionPayloadHeaderDeneb_messageType) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeaderDeneb)
}
func (x fastReflection_ExecutionPayloadHeaderDeneb_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeaderDeneb
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Descriptor() protoreflect.MessageDescriptor {
	return md_ExecutionPayloadHeaderDeneb
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Type() protoreflect.MessageType {
	return _fastReflection_ExecutionPayloadHeaderDeneb_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) New() protoreflect.Message {
	return new(fastReflection_ExecutionPayloadHeaderDeneb)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Interface() protoreflect.ProtoMessage {
	return (*ExecutionPayloadHeaderDeneb)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ParentHash) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentHash)
		if !f(fd_ExecutionPayloadHeaderDeneb_parent_hash, value) {
			return
		}
	}
	if len(x.FeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.FeeRecipient)
		if !f(fd_ExecutionPayloadHeaderDeneb_fee_recipient, value) {
			return
		}
	}
	if len(x.StateRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.StateRoot)
		if !f(fd_ExecutionPayloadHeaderDeneb_state_root, value) {
			return
		}
	}
	if len(x.ReceiptsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ReceiptsRoot)
		if !f(fd_ExecutionPayloadHeaderDeneb_receipts_root, value) {
			return
		}
	}
	if len(x.LogsBloom) != 0 {
		value := protoreflect.ValueOfBytes(x.LogsBloom)
		if !f(fd_ExecutionPayloadHeaderDeneb_logs_bloom, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_ExecutionPayloadHeaderDeneb_prev_randao, value) {
			return
		}
	}
	if x.BlockNumber != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlockNumber)
		if !f(fd_ExecutionPayloadHeaderDeneb_block_number, value) {
			return
		}
	}
	if x.GasLimit != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasLimit)
		if !f(fd_ExecutionPayloadHeaderDeneb_gas_limit, value) {
			return
		}
	}
	if x.GasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.GasUsed)
		if !f(fd_ExecutionPayloadHeaderDeneb_gas_used, value) {
			return
		}
	}
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_ExecutionPayloadHeaderDeneb_timestamp, value) {
			return
		}
	}
	if len(x.ExtraData) != 0 {
		value := protoreflect.ValueOfBytes(x.ExtraData)
		if !f(fd_ExecutionPayloadHeaderDeneb_extra_data, value) {
			return
		}
	}
	if len(x.BaseFeePerGas) != 0 {
		value := protoreflect.ValueOfBytes(x.BaseFeePerGas)
		if !f(fd_ExecutionPayloadHeaderDeneb_base_fee_per_gas, value) {
			return
		}
	}
	if len(x.BlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.BlockHash)
		if !f(fd_ExecutionPayloadHeaderDeneb_block_hash, value) {
			return
		}
	}
	if len(x.TransactionsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.TransactionsRoot)
		if !f(fd_ExecutionPayloadHeaderDeneb_transactions_root, value) {
			return
		}
	}
	if len(x.WithdrawalsRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.WithdrawalsRoot)
		if !f(fd_ExecutionPayloadHeaderDeneb_withdrawals_root, value) {
			return
		}
	}
	if x.BlobGasUsed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.BlobGasUsed)
		if !f(fd_ExecutionPayloadHeaderDeneb_blob_gas_used, value) {
			return
		}
	}
	if x.ExcessBlobGas != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ExcessBlobGas)
		if !f(fd_ExecutionPayloadHeaderDeneb_excess_blob_gas, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		return len(x.ParentHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		return len(x.FeeRecipient) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		return len(x.StateRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		return len(x.ReceiptsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		return len(x.LogsBloom) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		return x.BlockNumber != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		return x.GasLimit != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		return x.GasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		return len(x.ExtraData) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		return len(x.BaseFeePerGas) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		return len(x.BlockHash) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		return len(x.TransactionsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		return len(x.WithdrawalsRoot) != 0
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		return x.BlobGasUsed != uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		return x.ExcessBlobGas != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		x.ParentHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		x.FeeRecipient = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		x.StateRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		x.ReceiptsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		x.LogsBloom = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		x.BlockNumber = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		x.GasLimit = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		x.GasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		x.ExtraData = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		x.BaseFeePerGas = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		x.BlockHash = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		x.TransactionsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		x.WithdrawalsRoot = nil
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		x.BlobGasUsed = uint64(0)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		x.ExcessBlobGas = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		value := x.ParentHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		value := x.FeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		value := x.StateRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		value := x.ReceiptsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		value := x.LogsBloom
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		value := x.BlockNumber
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		value := x.GasLimit
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		value := x.GasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		value := x.ExtraData
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		value := x.BaseFeePerGas
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		value := x.BlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		value := x.TransactionsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		value := x.WithdrawalsRoot
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		value := x.BlobGasUsed
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		value := x.ExcessBlobGas
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		x.ParentHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		x.FeeRecipient = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		x.StateRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		x.ReceiptsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		x.LogsBloom = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		x.BlockNumber = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		x.GasLimit = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		x.GasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		x.ExtraData = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		x.BaseFeePerGas = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		x.BlockHash = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		x.TransactionsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		x.WithdrawalsRoot = value.Bytes()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		x.BlobGasUsed = value.Uint()
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		x.ExcessBlobGas = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		panic(fmt.Errorf("field parent_hash of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		panic(fmt.Errorf("field fee_recipient of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		panic(fmt.Errorf("field state_root of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		panic(fmt.Errorf("field receipts_root of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		panic(fmt.Errorf("field logs_bloom of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		panic(fmt.Errorf("field block_number of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		panic(fmt.Errorf("field gas_limit of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		panic(fmt.Errorf("field gas_used of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		panic(fmt.Errorf("field extra_data of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		panic(fmt.Errorf("field base_fee_per_gas of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		panic(fmt.Errorf("field block_hash of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		panic(fmt.Errorf("field transactions_root of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		panic(fmt.Errorf("field withdrawals_root of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		panic(fmt.Errorf("field blob_gas_used of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		panic(fmt.Errorf("field excess_blob_gas of message ethereum.engine.v1.ExecutionPayloadHeaderDeneb is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.parent_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.state_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.receipts_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.logs_bloom":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_number":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_limit":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.extra_data":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.base_fee_per_gas":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.transactions_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.withdrawals_root":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.blob_gas_used":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.ExecutionPayloadHeaderDeneb.excess_blob_gas":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExecutionPayloadHeaderDeneb"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExecutionPayloadHeaderDeneb does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExecutionPayloadHeaderDeneb", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExecutionPayloadHeaderDeneb) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExecutionPayloadHeaderDeneb)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ParentHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StateRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiptsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LogsBloom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockNumber != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockNumber))
		}
		if x.GasLimit != 0 {
			n += 1 + runtime.Sov(uint64(x.GasLimit))
		}
		if x.GasUsed != 0 {
			n += 1 + runtime.Sov(uint64(x.GasUsed))
		}
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.ExtraData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BaseFeePerGas)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TransactionsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WithdrawalsRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlobGasUsed != 0 {
			n += 2 + runtime.Sov(uint64(x.BlobGasUsed))
		}
		if x.ExcessBlobGas != 0 {
			n += 2 + runtime.Sov(uint64(x.ExcessBlobGas))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeaderDeneb)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExcessBlobGas != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ExcessBlobGas))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x88
		}
		if x.BlobGasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlobGasUsed))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x80
		}
		if len(x.WithdrawalsRoot) > 0 {
			i -= len(x.WithdrawalsRoot)
			copy(dAtA[i:], x.WithdrawalsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WithdrawalsRoot)))
			i--
			dAtA[i] = 0x7a
		}
		if len(x.TransactionsRoot) > 0 {
			i -= len(x.TransactionsRoot)
			copy(dAtA[i:], x.TransactionsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionsRoot)))
			i--
			dAtA[i] = 0x72
		}
		if len(x.BlockHash) > 0 {
			i -= len(x.BlockHash)
			copy(dAtA[i:], x.BlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlockHash)))
			i--
			dAtA[i] = 0x6a
		}
		if len(x.BaseFeePerGas) > 0 {
			i -= len(x.BaseFeePerGas)
			copy(dAtA[i:], x.BaseFeePerGas)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BaseFeePerGas)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ExtraData) > 0 {
			i -= len(x.ExtraData)
			copy(dAtA[i:], x.ExtraData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExtraData)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x50
		}
		if x.GasUsed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasUsed))
			i--
			dAtA[i] = 0x48
		}
		if x.GasLimit != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.GasLimit))
			i--
			dAtA[i] = 0x40
		}
		if x.BlockNumber != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockNumber))
			i--
			dAtA[i] = 0x38
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LogsBloom) > 0 {
			i -= len(x.LogsBloom)
			copy(dAtA[i:], x.LogsBloom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LogsBloom)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ReceiptsRoot) > 0 {
			i -= len(x.ReceiptsRoot)
			copy(dAtA[i:], x.ReceiptsRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiptsRoot)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.StateRoot) > 0 {
			i -= len(x.StateRoot)
			copy(dAtA[i:], x.StateRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StateRoot)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.FeeRecipient) > 0 {
			i -= len(x.FeeRecipient)
			copy(dAtA[i:], x.FeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeRecipient)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ParentHash) > 0 {
			i -= len(x.ParentHash)
			copy(dAtA[i:], x.ParentHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExecutionPayloadHeaderDeneb)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeaderDeneb: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExecutionPayloadHeaderDeneb: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentHash = append(x.ParentHash[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentHash == nil {
					x.ParentHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeRecipient = append(x.FeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.FeeRecipient == nil {
					x.FeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StateRoot = append(x.StateRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.StateRoot == nil {
					x.StateRoot = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiptsRoot = append(x.ReceiptsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ReceiptsRoot == nil {
					x.ReceiptsRoot = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LogsBloom = append(x.LogsBloom[:0], dAtA[iNdEx:postIndex]...)
				if x.LogsBloom == nil {
					x.LogsBloom = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
				}
				x.BlockNumber = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockNumber |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
				}
				x.GasLimit = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasLimit |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
				}
				x.GasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.GasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExtraData = append(x.ExtraData[:0], dAtA[iNdEx:postIndex]...)
				if x.ExtraData == nil {
					x.ExtraData = []byte{}
				}
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BaseFeePerGas", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BaseFeePerGas = append(x.BaseFeePerGas[:0], dAtA[iNdEx:postIndex]...)
				if x.BaseFeePerGas == nil {
					x.BaseFeePerGas = []byte{}
				}
				iNdEx = postIndex
			case 13:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlockHash = append(x.BlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.BlockHash == nil {
					x.BlockHash = []byte{}
				}
				iNdEx = postIndex
			case 14:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionsRoot = append(x.TransactionsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.TransactionsRoot == nil {
					x.TransactionsRoot = []byte{}
				}
				iNdEx = postIndex
			case 15:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WithdrawalsRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WithdrawalsRoot = append(x.WithdrawalsRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.WithdrawalsRoot == nil {
					x.WithdrawalsRoot = []byte{}
				}
				iNdEx = postIndex
			case 16:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlobGasUsed", wireType)
				}
				x.BlobGasUsed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlobGasUsed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 17:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExcessBlobGas", wireType)
				}
				x.ExcessBlobGas = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ExcessBlobGas |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PayloadAttributes                         protoreflect.MessageDescriptor
	fd_PayloadAttributes_timestamp               protoreflect.FieldDescriptor
	fd_PayloadAttributes_prev_randao             protoreflect.FieldDescriptor
	fd_PayloadAttributes_suggested_fee_recipient protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_PayloadAttributes = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("PayloadAttributes")
	fd_PayloadAttributes_timestamp = md_PayloadAttributes.Fields().ByName("timestamp")
	fd_PayloadAttributes_prev_randao = md_PayloadAttributes.Fields().ByName("prev_randao")
	fd_PayloadAttributes_suggested_fee_recipient = md_PayloadAttributes.Fields().ByName("suggested_fee_recipient")
}

var _ protoreflect.Message = (*fastReflection_PayloadAttributes)(nil)

type fastReflection_PayloadAttributes PayloadAttributes

func (x *PayloadAttributes) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PayloadAttributes)(x)
}

func (x *PayloadAttributes) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PayloadAttributes_messageType fastReflection_PayloadAttributes_messageType
var _ protoreflect.MessageType = fastReflection_PayloadAttributes_messageType{}

type fastReflection_PayloadAttributes_messageType struct{}

func (x fastReflection_PayloadAttributes_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PayloadAttributes)(nil)
}
func (x fastReflection_PayloadAttributes_messageType) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributes)
}
func (x fastReflection_PayloadAttributes_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributes
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PayloadAttributes) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributes
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PayloadAttributes) Type() protoreflect.MessageType {
	return _fastReflection_PayloadAttributes_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PayloadAttributes) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributes)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PayloadAttributes) Interface() protoreflect.ProtoMessage {
	return (*PayloadAttributes)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PayloadAttributes) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_PayloadAttributes_timestamp, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_PayloadAttributes_prev_randao, value) {
			return
		}
	}
	if len(x.SuggestedFeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.SuggestedFeeRecipient)
		if !f(fd_PayloadAttributes_suggested_fee_recipient, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PayloadAttributes) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		return len(x.SuggestedFeeRecipient) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributes) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		x.SuggestedFeeRecipient = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PayloadAttributes) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		value := x.SuggestedFeeRecipient
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributes) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		x.SuggestedFeeRecipient = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributes) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.PayloadAttributes is not mutable"))
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.PayloadAttributes is not mutable"))
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		panic(fmt.Errorf("field suggested_fee_recipient of message ethereum.engine.v1.PayloadAttributes is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PayloadAttributes) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributes.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.PayloadAttributes.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadAttributes.suggested_fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributes"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributes does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PayloadAttributes) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.PayloadAttributes", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PayloadAttributes) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributes) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PayloadAttributes) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PayloadAttributes) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PayloadAttributes)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SuggestedFeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributes)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SuggestedFeeRecipient) > 0 {
			i -= len(x.SuggestedFeeRecipient)
			copy(dAtA[i:], x.SuggestedFeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SuggestedFeeRecipient)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x12
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributes)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributes: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SuggestedFeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SuggestedFeeRecipient = append(x.SuggestedFeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.SuggestedFeeRecipient == nil {
					x.SuggestedFeeRecipient = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PayloadAttributesV2_4_list)(nil)

type _PayloadAttributesV2_4_list struct {
	list *[]*Withdrawal
}

func (x *_PayloadAttributesV2_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PayloadAttributesV2_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_PayloadAttributesV2_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	(*x.list)[i] = concreteValue
}

func (x *_PayloadAttributesV2_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	*x.list = append(*x.list, concreteValue)
}

func (x *_PayloadAttributesV2_4_list) AppendMutable() protoreflect.Value {
	v := new(Withdrawal)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PayloadAttributesV2_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_PayloadAttributesV2_4_list) NewElement() protoreflect.Value {
	v := new(Withdrawal)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PayloadAttributesV2_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PayloadAttributesV2                         protoreflect.MessageDescriptor
	fd_PayloadAttributesV2_timestamp               protoreflect.FieldDescriptor
	fd_PayloadAttributesV2_prev_randao             protoreflect.FieldDescriptor
	fd_PayloadAttributesV2_suggested_fee_recipient protoreflect.FieldDescriptor
	fd_PayloadAttributesV2_withdrawals             protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_PayloadAttributesV2 = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("PayloadAttributesV2")
	fd_PayloadAttributesV2_timestamp = md_PayloadAttributesV2.Fields().ByName("timestamp")
	fd_PayloadAttributesV2_prev_randao = md_PayloadAttributesV2.Fields().ByName("prev_randao")
	fd_PayloadAttributesV2_suggested_fee_recipient = md_PayloadAttributesV2.Fields().ByName("suggested_fee_recipient")
	fd_PayloadAttributesV2_withdrawals = md_PayloadAttributesV2.Fields().ByName("withdrawals")
}

var _ protoreflect.Message = (*fastReflection_PayloadAttributesV2)(nil)

type fastReflection_PayloadAttributesV2 PayloadAttributesV2

func (x *PayloadAttributesV2) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PayloadAttributesV2)(x)
}

func (x *PayloadAttributesV2) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PayloadAttributesV2_messageType fastReflection_PayloadAttributesV2_messageType
var _ protoreflect.MessageType = fastReflection_PayloadAttributesV2_messageType{}

type fastReflection_PayloadAttributesV2_messageType struct{}

func (x fastReflection_PayloadAttributesV2_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PayloadAttributesV2)(nil)
}
func (x fastReflection_PayloadAttributesV2_messageType) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributesV2)
}
func (x fastReflection_PayloadAttributesV2_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributesV2
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PayloadAttributesV2) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributesV2
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PayloadAttributesV2) Type() protoreflect.MessageType {
	return _fastReflection_PayloadAttributesV2_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PayloadAttributesV2) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributesV2)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PayloadAttributesV2) Interface() protoreflect.ProtoMessage {
	return (*PayloadAttributesV2)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PayloadAttributesV2) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_PayloadAttributesV2_timestamp, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_PayloadAttributesV2_prev_randao, value) {
			return
		}
	}
	if len(x.SuggestedFeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.SuggestedFeeRecipient)
		if !f(fd_PayloadAttributesV2_suggested_fee_recipient, value) {
			return
		}
	}
	if len(x.Withdrawals) != 0 {
		value := protoreflect.ValueOfList(&_PayloadAttributesV2_4_list{list: &x.Withdrawals})
		if !f(fd_PayloadAttributesV2_withdrawals, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PayloadAttributesV2) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		return len(x.SuggestedFeeRecipient) != 0
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		return len(x.Withdrawals) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV2) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		x.SuggestedFeeRecipient = nil
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		x.Withdrawals = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PayloadAttributesV2) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		value := x.SuggestedFeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		if len(x.Withdrawals) == 0 {
			return protoreflect.ValueOfList(&_PayloadAttributesV2_4_list{})
		}
		listValue := &_PayloadAttributesV2_4_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV2) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		x.SuggestedFeeRecipient = value.Bytes()
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		lv := value.List()
		clv := lv.(*_PayloadAttributesV2_4_list)
		x.Withdrawals = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV2) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		if x.Withdrawals == nil {
			x.Withdrawals = []*Withdrawal{}
		}
		value := &_PayloadAttributesV2_4_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.PayloadAttributesV2 is not mutable"))
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.PayloadAttributesV2 is not mutable"))
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		panic(fmt.Errorf("field suggested_fee_recipient of message ethereum.engine.v1.PayloadAttributesV2 is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PayloadAttributesV2) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV2.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.PayloadAttributesV2.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadAttributesV2.suggested_fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadAttributesV2.withdrawals":
		list := []*Withdrawal{}
		return protoreflect.ValueOfList(&_PayloadAttributesV2_4_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV2"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV2 does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PayloadAttributesV2) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.PayloadAttributesV2", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PayloadAttributesV2) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV2) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PayloadAttributesV2) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PayloadAttributesV2) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PayloadAttributesV2)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SuggestedFeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Withdrawals) > 0 {
			for _, e := range x.Withdrawals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributesV2)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Withdrawals) > 0 {
			for iNdEx := len(x.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Withdrawals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.SuggestedFeeRecipient) > 0 {
			i -= len(x.SuggestedFeeRecipient)
			copy(dAtA[i:], x.SuggestedFeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SuggestedFeeRecipient)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x12
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributesV2)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributesV2: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributesV2: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SuggestedFeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SuggestedFeeRecipient = append(x.SuggestedFeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.SuggestedFeeRecipient == nil {
					x.SuggestedFeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Withdrawals = append(x.Withdrawals, &Withdrawal{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Withdrawals[len(x.Withdrawals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PayloadAttributesV3_4_list)(nil)

type _PayloadAttributesV3_4_list struct {
	list *[]*Withdrawal
}

func (x *_PayloadAttributesV3_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PayloadAttributesV3_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_PayloadAttributesV3_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	(*x.list)[i] = concreteValue
}

func (x *_PayloadAttributesV3_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Withdrawal)
	*x.list = append(*x.list, concreteValue)
}

func (x *_PayloadAttributesV3_4_list) AppendMutable() protoreflect.Value {
	v := new(Withdrawal)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PayloadAttributesV3_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_PayloadAttributesV3_4_list) NewElement() protoreflect.Value {
	v := new(Withdrawal)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PayloadAttributesV3_4_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PayloadAttributesV3                          protoreflect.MessageDescriptor
	fd_PayloadAttributesV3_timestamp                protoreflect.FieldDescriptor
	fd_PayloadAttributesV3_prev_randao              protoreflect.FieldDescriptor
	fd_PayloadAttributesV3_suggested_fee_recipient  protoreflect.FieldDescriptor
	fd_PayloadAttributesV3_withdrawals              protoreflect.FieldDescriptor
	fd_PayloadAttributesV3_parent_beacon_block_root protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_PayloadAttributesV3 = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("PayloadAttributesV3")
	fd_PayloadAttributesV3_timestamp = md_PayloadAttributesV3.Fields().ByName("timestamp")
	fd_PayloadAttributesV3_prev_randao = md_PayloadAttributesV3.Fields().ByName("prev_randao")
	fd_PayloadAttributesV3_suggested_fee_recipient = md_PayloadAttributesV3.Fields().ByName("suggested_fee_recipient")
	fd_PayloadAttributesV3_withdrawals = md_PayloadAttributesV3.Fields().ByName("withdrawals")
	fd_PayloadAttributesV3_parent_beacon_block_root = md_PayloadAttributesV3.Fields().ByName("parent_beacon_block_root")
}

var _ protoreflect.Message = (*fastReflection_PayloadAttributesV3)(nil)

type fastReflection_PayloadAttributesV3 PayloadAttributesV3

func (x *PayloadAttributesV3) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PayloadAttributesV3)(x)
}

func (x *PayloadAttributesV3) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PayloadAttributesV3_messageType fastReflection_PayloadAttributesV3_messageType
var _ protoreflect.MessageType = fastReflection_PayloadAttributesV3_messageType{}

type fastReflection_PayloadAttributesV3_messageType struct{}

func (x fastReflection_PayloadAttributesV3_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PayloadAttributesV3)(nil)
}
func (x fastReflection_PayloadAttributesV3_messageType) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributesV3)
}
func (x fastReflection_PayloadAttributesV3_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributesV3
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PayloadAttributesV3) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadAttributesV3
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PayloadAttributesV3) Type() protoreflect.MessageType {
	return _fastReflection_PayloadAttributesV3_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PayloadAttributesV3) New() protoreflect.Message {
	return new(fastReflection_PayloadAttributesV3)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PayloadAttributesV3) Interface() protoreflect.ProtoMessage {
	return (*PayloadAttributesV3)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PayloadAttributesV3) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Timestamp != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Timestamp)
		if !f(fd_PayloadAttributesV3_timestamp, value) {
			return
		}
	}
	if len(x.PrevRandao) != 0 {
		value := protoreflect.ValueOfBytes(x.PrevRandao)
		if !f(fd_PayloadAttributesV3_prev_randao, value) {
			return
		}
	}
	if len(x.SuggestedFeeRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.SuggestedFeeRecipient)
		if !f(fd_PayloadAttributesV3_suggested_fee_recipient, value) {
			return
		}
	}
	if len(x.Withdrawals) != 0 {
		value := protoreflect.ValueOfList(&_PayloadAttributesV3_4_list{list: &x.Withdrawals})
		if !f(fd_PayloadAttributesV3_withdrawals, value) {
			return
		}
	}
	if len(x.ParentBeaconBlockRoot) != 0 {
		value := protoreflect.ValueOfBytes(x.ParentBeaconBlockRoot)
		if !f(fd_PayloadAttributesV3_parent_beacon_block_root, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PayloadAttributesV3) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		return x.Timestamp != uint64(0)
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		return len(x.PrevRandao) != 0
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		return len(x.SuggestedFeeRecipient) != 0
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		return len(x.Withdrawals) != 0
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		return len(x.ParentBeaconBlockRoot) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV3) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		x.Timestamp = uint64(0)
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		x.PrevRandao = nil
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		x.SuggestedFeeRecipient = nil
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		x.Withdrawals = nil
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		x.ParentBeaconBlockRoot = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PayloadAttributesV3) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		value := x.PrevRandao
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		value := x.SuggestedFeeRecipient
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		if len(x.Withdrawals) == 0 {
			return protoreflect.ValueOfList(&_PayloadAttributesV3_4_list{})
		}
		listValue := &_PayloadAttributesV3_4_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		value := x.ParentBeaconBlockRoot
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV3) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		x.Timestamp = value.Uint()
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		x.PrevRandao = value.Bytes()
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		x.SuggestedFeeRecipient = value.Bytes()
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		lv := value.List()
		clv := lv.(*_PayloadAttributesV3_4_list)
		x.Withdrawals = *clv.list
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		x.ParentBeaconBlockRoot = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV3) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		if x.Withdrawals == nil {
			x.Withdrawals = []*Withdrawal{}
		}
		value := &_PayloadAttributesV3_4_list{list: &x.Withdrawals}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		panic(fmt.Errorf("field timestamp of message ethereum.engine.v1.PayloadAttributesV3 is not mutable"))
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		panic(fmt.Errorf("field prev_randao of message ethereum.engine.v1.PayloadAttributesV3 is not mutable"))
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		panic(fmt.Errorf("field suggested_fee_recipient of message ethereum.engine.v1.PayloadAttributesV3 is not mutable"))
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		panic(fmt.Errorf("field parent_beacon_block_root of message ethereum.engine.v1.PayloadAttributesV3 is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PayloadAttributesV3) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadAttributesV3.timestamp":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.PayloadAttributesV3.prev_randao":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadAttributesV3.suggested_fee_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadAttributesV3.withdrawals":
		list := []*Withdrawal{}
		return protoreflect.ValueOfList(&_PayloadAttributesV3_4_list{list: &list})
	case "ethereum.engine.v1.PayloadAttributesV3.parent_beacon_block_root":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadAttributesV3"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadAttributesV3 does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PayloadAttributesV3) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.PayloadAttributesV3", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PayloadAttributesV3) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadAttributesV3) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PayloadAttributesV3) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PayloadAttributesV3) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PayloadAttributesV3)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Timestamp != 0 {
			n += 1 + runtime.Sov(uint64(x.Timestamp))
		}
		l = len(x.PrevRandao)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SuggestedFeeRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Withdrawals) > 0 {
			for _, e := range x.Withdrawals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.ParentBeaconBlockRoot)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributesV3)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ParentBeaconBlockRoot) > 0 {
			i -= len(x.ParentBeaconBlockRoot)
			copy(dAtA[i:], x.ParentBeaconBlockRoot)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ParentBeaconBlockRoot)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Withdrawals) > 0 {
			for iNdEx := len(x.Withdrawals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Withdrawals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.SuggestedFeeRecipient) > 0 {
			i -= len(x.SuggestedFeeRecipient)
			copy(dAtA[i:], x.SuggestedFeeRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SuggestedFeeRecipient)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PrevRandao) > 0 {
			i -= len(x.PrevRandao)
			copy(dAtA[i:], x.PrevRandao)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrevRandao)))
			i--
			dAtA[i] = 0x12
		}
		if x.Timestamp != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Timestamp))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PayloadAttributesV3)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributesV3: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadAttributesV3: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				x.Timestamp = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Timestamp |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrevRandao", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrevRandao = append(x.PrevRandao[:0], dAtA[iNdEx:postIndex]...)
				if x.PrevRandao == nil {
					x.PrevRandao = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SuggestedFeeRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SuggestedFeeRecipient = append(x.SuggestedFeeRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.SuggestedFeeRecipient == nil {
					x.SuggestedFeeRecipient = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Withdrawals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Withdrawals = append(x.Withdrawals, &Withdrawal{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Withdrawals[len(x.Withdrawals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ParentBeaconBlockRoot", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ParentBeaconBlockRoot = append(x.ParentBeaconBlockRoot[:0], dAtA[iNdEx:postIndex]...)
				if x.ParentBeaconBlockRoot == nil {
					x.ParentBeaconBlockRoot = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PayloadStatus                   protoreflect.MessageDescriptor
	fd_PayloadStatus_status            protoreflect.FieldDescriptor
	fd_PayloadStatus_latest_valid_hash protoreflect.FieldDescriptor
	fd_PayloadStatus_validation_error  protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_PayloadStatus = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("PayloadStatus")
	fd_PayloadStatus_status = md_PayloadStatus.Fields().ByName("status")
	fd_PayloadStatus_latest_valid_hash = md_PayloadStatus.Fields().ByName("latest_valid_hash")
	fd_PayloadStatus_validation_error = md_PayloadStatus.Fields().ByName("validation_error")
}

var _ protoreflect.Message = (*fastReflection_PayloadStatus)(nil)

type fastReflection_PayloadStatus PayloadStatus

func (x *PayloadStatus) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PayloadStatus)(x)
}

func (x *PayloadStatus) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PayloadStatus_messageType fastReflection_PayloadStatus_messageType
var _ protoreflect.MessageType = fastReflection_PayloadStatus_messageType{}

type fastReflection_PayloadStatus_messageType struct{}

func (x fastReflection_PayloadStatus_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PayloadStatus)(nil)
}
func (x fastReflection_PayloadStatus_messageType) New() protoreflect.Message {
	return new(fastReflection_PayloadStatus)
}
func (x fastReflection_PayloadStatus_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadStatus
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PayloadStatus) Descriptor() protoreflect.MessageDescriptor {
	return md_PayloadStatus
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PayloadStatus) Type() protoreflect.MessageType {
	return _fastReflection_PayloadStatus_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PayloadStatus) New() protoreflect.Message {
	return new(fastReflection_PayloadStatus)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PayloadStatus) Interface() protoreflect.ProtoMessage {
	return (*PayloadStatus)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PayloadStatus) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_PayloadStatus_status, value) {
			return
		}
	}
	if len(x.LatestValidHash) != 0 {
		value := protoreflect.ValueOfBytes(x.LatestValidHash)
		if !f(fd_PayloadStatus_latest_valid_hash, value) {
			return
		}
	}
	if x.ValidationError != "" {
		value := protoreflect.ValueOfString(x.ValidationError)
		if !f(fd_PayloadStatus_validation_error, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PayloadStatus) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		return x.Status != 0
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		return len(x.LatestValidHash) != 0
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		return x.ValidationError != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadStatus) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		x.Status = 0
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		x.LatestValidHash = nil
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		x.ValidationError = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PayloadStatus) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		value := x.LatestValidHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		value := x.ValidationError
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadStatus) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		x.Status = (PayloadStatus_Status)(value.Enum())
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		x.LatestValidHash = value.Bytes()
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		x.ValidationError = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadStatus) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		panic(fmt.Errorf("field status of message ethereum.engine.v1.PayloadStatus is not mutable"))
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		panic(fmt.Errorf("field latest_valid_hash of message ethereum.engine.v1.PayloadStatus is not mutable"))
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		panic(fmt.Errorf("field validation_error of message ethereum.engine.v1.PayloadStatus is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PayloadStatus) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.PayloadStatus.status":
		return protoreflect.ValueOfEnum(0)
	case "ethereum.engine.v1.PayloadStatus.latest_valid_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.PayloadStatus.validation_error":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.PayloadStatus"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.PayloadStatus does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PayloadStatus) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.PayloadStatus", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PayloadStatus) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PayloadStatus) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PayloadStatus) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PayloadStatus) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PayloadStatus)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		l = len(x.LatestValidHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ValidationError)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PayloadStatus)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ValidationError) > 0 {
			i -= len(x.ValidationError)
			copy(dAtA[i:], x.ValidationError)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ValidationError)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.LatestValidHash) > 0 {
			i -= len(x.LatestValidHash)
			copy(dAtA[i:], x.LatestValidHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LatestValidHash)))
			i--
			dAtA[i] = 0x12
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PayloadStatus)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadStatus: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PayloadStatus: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= PayloadStatus_Status(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LatestValidHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LatestValidHash = append(x.LatestValidHash[:0], dAtA[iNdEx:postIndex]...)
				if x.LatestValidHash == nil {
					x.LatestValidHash = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValidationError", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ValidationError = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ForkchoiceState                      protoreflect.MessageDescriptor
	fd_ForkchoiceState_head_block_hash      protoreflect.FieldDescriptor
	fd_ForkchoiceState_safe_block_hash      protoreflect.FieldDescriptor
	fd_ForkchoiceState_finalized_block_hash protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ForkchoiceState = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ForkchoiceState")
	fd_ForkchoiceState_head_block_hash = md_ForkchoiceState.Fields().ByName("head_block_hash")
	fd_ForkchoiceState_safe_block_hash = md_ForkchoiceState.Fields().ByName("safe_block_hash")
	fd_ForkchoiceState_finalized_block_hash = md_ForkchoiceState.Fields().ByName("finalized_block_hash")
}

var _ protoreflect.Message = (*fastReflection_ForkchoiceState)(nil)

type fastReflection_ForkchoiceState ForkchoiceState

func (x *ForkchoiceState) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ForkchoiceState)(x)
}

func (x *ForkchoiceState) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ForkchoiceState_messageType fastReflection_ForkchoiceState_messageType
var _ protoreflect.MessageType = fastReflection_ForkchoiceState_messageType{}

type fastReflection_ForkchoiceState_messageType struct{}

func (x fastReflection_ForkchoiceState_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ForkchoiceState)(nil)
}
func (x fastReflection_ForkchoiceState_messageType) New() protoreflect.Message {
	return new(fastReflection_ForkchoiceState)
}
func (x fastReflection_ForkchoiceState_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ForkchoiceState
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ForkchoiceState) Descriptor() protoreflect.MessageDescriptor {
	return md_ForkchoiceState
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ForkchoiceState) Type() protoreflect.MessageType {
	return _fastReflection_ForkchoiceState_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ForkchoiceState) New() protoreflect.Message {
	return new(fastReflection_ForkchoiceState)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ForkchoiceState) Interface() protoreflect.ProtoMessage {
	return (*ForkchoiceState)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ForkchoiceState) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.HeadBlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.HeadBlockHash)
		if !f(fd_ForkchoiceState_head_block_hash, value) {
			return
		}
	}
	if len(x.SafeBlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.SafeBlockHash)
		if !f(fd_ForkchoiceState_safe_block_hash, value) {
			return
		}
	}
	if len(x.FinalizedBlockHash) != 0 {
		value := protoreflect.ValueOfBytes(x.FinalizedBlockHash)
		if !f(fd_ForkchoiceState_finalized_block_hash, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ForkchoiceState) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		return len(x.HeadBlockHash) != 0
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		return len(x.SafeBlockHash) != 0
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		return len(x.FinalizedBlockHash) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ForkchoiceState) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		x.HeadBlockHash = nil
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		x.SafeBlockHash = nil
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		x.FinalizedBlockHash = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ForkchoiceState) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		value := x.HeadBlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		value := x.SafeBlockHash
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		value := x.FinalizedBlockHash
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ForkchoiceState) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		x.HeadBlockHash = value.Bytes()
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		x.SafeBlockHash = value.Bytes()
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		x.FinalizedBlockHash = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ForkchoiceState) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		panic(fmt.Errorf("field head_block_hash of message ethereum.engine.v1.ForkchoiceState is not mutable"))
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		panic(fmt.Errorf("field safe_block_hash of message ethereum.engine.v1.ForkchoiceState is not mutable"))
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		panic(fmt.Errorf("field finalized_block_hash of message ethereum.engine.v1.ForkchoiceState is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ForkchoiceState) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ForkchoiceState.head_block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ForkchoiceState.safe_block_hash":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.ForkchoiceState.finalized_block_hash":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ForkchoiceState"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ForkchoiceState does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ForkchoiceState) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ForkchoiceState", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ForkchoiceState) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ForkchoiceState) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ForkchoiceState) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ForkchoiceState) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ForkchoiceState)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.HeadBlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SafeBlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FinalizedBlockHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ForkchoiceState)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.FinalizedBlockHash) > 0 {
			i -= len(x.FinalizedBlockHash)
			copy(dAtA[i:], x.FinalizedBlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FinalizedBlockHash)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.SafeBlockHash) > 0 {
			i -= len(x.SafeBlockHash)
			copy(dAtA[i:], x.SafeBlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SafeBlockHash)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.HeadBlockHash) > 0 {
			i -= len(x.HeadBlockHash)
			copy(dAtA[i:], x.HeadBlockHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.HeadBlockHash)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ForkchoiceState)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ForkchoiceState: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ForkchoiceState: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HeadBlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.HeadBlockHash = append(x.HeadBlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.HeadBlockHash == nil {
					x.HeadBlockHash = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SafeBlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SafeBlockHash = append(x.SafeBlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.SafeBlockHash == nil {
					x.SafeBlockHash = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FinalizedBlockHash", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FinalizedBlockHash = append(x.FinalizedBlockHash[:0], dAtA[iNdEx:postIndex]...)
				if x.FinalizedBlockHash == nil {
					x.FinalizedBlockHash = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Withdrawal                 protoreflect.MessageDescriptor
	fd_Withdrawal_index           protoreflect.FieldDescriptor
	fd_Withdrawal_validator_index protoreflect.FieldDescriptor
	fd_Withdrawal_address         protoreflect.FieldDescriptor
	fd_Withdrawal_amount          protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_Withdrawal = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("Withdrawal")
	fd_Withdrawal_index = md_Withdrawal.Fields().ByName("index")
	fd_Withdrawal_validator_index = md_Withdrawal.Fields().ByName("validator_index")
	fd_Withdrawal_address = md_Withdrawal.Fields().ByName("address")
	fd_Withdrawal_amount = md_Withdrawal.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_Withdrawal)(nil)

type fastReflection_Withdrawal Withdrawal

func (x *Withdrawal) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Withdrawal)(x)
}

func (x *Withdrawal) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Withdrawal_messageType fastReflection_Withdrawal_messageType
var _ protoreflect.MessageType = fastReflection_Withdrawal_messageType{}

type fastReflection_Withdrawal_messageType struct{}

func (x fastReflection_Withdrawal_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Withdrawal)(nil)
}
func (x fastReflection_Withdrawal_messageType) New() protoreflect.Message {
	return new(fastReflection_Withdrawal)
}
func (x fastReflection_Withdrawal_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Withdrawal
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Withdrawal) Descriptor() protoreflect.MessageDescriptor {
	return md_Withdrawal
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Withdrawal) Type() protoreflect.MessageType {
	return _fastReflection_Withdrawal_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Withdrawal) New() protoreflect.Message {
	return new(fastReflection_Withdrawal)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Withdrawal) Interface() protoreflect.ProtoMessage {
	return (*Withdrawal)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Withdrawal) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Index != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Index)
		if !f(fd_Withdrawal_index, value) {
			return
		}
	}
	if x.ValidatorIndex != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ValidatorIndex)
		if !f(fd_Withdrawal_validator_index, value) {
			return
		}
	}
	if len(x.Address) != 0 {
		value := protoreflect.ValueOfBytes(x.Address)
		if !f(fd_Withdrawal_address, value) {
			return
		}
	}
	if x.Amount != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Amount)
		if !f(fd_Withdrawal_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Withdrawal) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		return x.Index != uint64(0)
	case "ethereum.engine.v1.Withdrawal.validator_index":
		return x.ValidatorIndex != uint64(0)
	case "ethereum.engine.v1.Withdrawal.address":
		return len(x.Address) != 0
	case "ethereum.engine.v1.Withdrawal.amount":
		return x.Amount != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Withdrawal) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		x.Index = uint64(0)
	case "ethereum.engine.v1.Withdrawal.validator_index":
		x.ValidatorIndex = uint64(0)
	case "ethereum.engine.v1.Withdrawal.address":
		x.Address = nil
	case "ethereum.engine.v1.Withdrawal.amount":
		x.Amount = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Withdrawal) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		value := x.Index
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.Withdrawal.validator_index":
		value := x.ValidatorIndex
		return protoreflect.ValueOfUint64(value)
	case "ethereum.engine.v1.Withdrawal.address":
		value := x.Address
		return protoreflect.ValueOfBytes(value)
	case "ethereum.engine.v1.Withdrawal.amount":
		value := x.Amount
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Withdrawal) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		x.Index = value.Uint()
	case "ethereum.engine.v1.Withdrawal.validator_index":
		x.ValidatorIndex = value.Uint()
	case "ethereum.engine.v1.Withdrawal.address":
		x.Address = value.Bytes()
	case "ethereum.engine.v1.Withdrawal.amount":
		x.Amount = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Withdrawal) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		panic(fmt.Errorf("field index of message ethereum.engine.v1.Withdrawal is not mutable"))
	case "ethereum.engine.v1.Withdrawal.validator_index":
		panic(fmt.Errorf("field validator_index of message ethereum.engine.v1.Withdrawal is not mutable"))
	case "ethereum.engine.v1.Withdrawal.address":
		panic(fmt.Errorf("field address of message ethereum.engine.v1.Withdrawal is not mutable"))
	case "ethereum.engine.v1.Withdrawal.amount":
		panic(fmt.Errorf("field amount of message ethereum.engine.v1.Withdrawal is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Withdrawal) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.Withdrawal.index":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.Withdrawal.validator_index":
		return protoreflect.ValueOfUint64(uint64(0))
	case "ethereum.engine.v1.Withdrawal.address":
		return protoreflect.ValueOfBytes(nil)
	case "ethereum.engine.v1.Withdrawal.amount":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Withdrawal"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Withdrawal does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Withdrawal) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.Withdrawal", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Withdrawal) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Withdrawal) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Withdrawal) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Withdrawal) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Withdrawal)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Index != 0 {
			n += 1 + runtime.Sov(uint64(x.Index))
		}
		if x.ValidatorIndex != 0 {
			n += 1 + runtime.Sov(uint64(x.ValidatorIndex))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != 0 {
			n += 1 + runtime.Sov(uint64(x.Amount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Withdrawal)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Amount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Amount))
			i--
			dAtA[i] = 0x20
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x1a
		}
		if x.ValidatorIndex != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ValidatorIndex))
			i--
			dAtA[i] = 0x10
		}
		if x.Index != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Index))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Withdrawal)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Withdrawal: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Withdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
				}
				x.Index = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Index |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValidatorIndex", wireType)
				}
				x.ValidatorIndex = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ValidatorIndex |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = append(x.Address[:0], dAtA[iNdEx:postIndex]...)
				if x.Address == nil {
					x.Address = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				x.Amount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Amount |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_BlobsBundle_1_list)(nil)

type _BlobsBundle_1_list struct {
	list *[][]byte
}

func (x *_BlobsBundle_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_BlobsBundle_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_BlobsBundle_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_BlobsBundle_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_BlobsBundle_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message BlobsBundle at list field KzgCommitments as it is not of Message kind"))
}

func (x *_BlobsBundle_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_BlobsBundle_1_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_BlobsBundle_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_BlobsBundle_2_list)(nil)

type _BlobsBundle_2_list struct {
	list *[][]byte
}

func (x *_BlobsBundle_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_BlobsBundle_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_BlobsBundle_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_BlobsBundle_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_BlobsBundle_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message BlobsBundle at list field Proofs as it is not of Message kind"))
}

func (x *_BlobsBundle_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_BlobsBundle_2_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_BlobsBundle_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_BlobsBundle_3_list)(nil)

type _BlobsBundle_3_list struct {
	list *[][]byte
}

func (x *_BlobsBundle_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_BlobsBundle_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfBytes((*x.list)[i])
}

func (x *_BlobsBundle_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_BlobsBundle_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Bytes()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_BlobsBundle_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message BlobsBundle at list field Blobs as it is not of Message kind"))
}

func (x *_BlobsBundle_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_BlobsBundle_3_list) NewElement() protoreflect.Value {
	var v []byte
	return protoreflect.ValueOfBytes(v)
}

func (x *_BlobsBundle_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_BlobsBundle                 protoreflect.MessageDescriptor
	fd_BlobsBundle_kzg_commitments protoreflect.FieldDescriptor
	fd_BlobsBundle_proofs          protoreflect.FieldDescriptor
	fd_BlobsBundle_blobs           protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_BlobsBundle = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("BlobsBundle")
	fd_BlobsBundle_kzg_commitments = md_BlobsBundle.Fields().ByName("kzg_commitments")
	fd_BlobsBundle_proofs = md_BlobsBundle.Fields().ByName("proofs")
	fd_BlobsBundle_blobs = md_BlobsBundle.Fields().ByName("blobs")
}

var _ protoreflect.Message = (*fastReflection_BlobsBundle)(nil)

type fastReflection_BlobsBundle BlobsBundle

func (x *BlobsBundle) ProtoReflect() protoreflect.Message {
	return (*fastReflection_BlobsBundle)(x)
}

func (x *BlobsBundle) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_BlobsBundle_messageType fastReflection_BlobsBundle_messageType
var _ protoreflect.MessageType = fastReflection_BlobsBundle_messageType{}

type fastReflection_BlobsBundle_messageType struct{}

func (x fastReflection_BlobsBundle_messageType) Zero() protoreflect.Message {
	return (*fastReflection_BlobsBundle)(nil)
}
func (x fastReflection_BlobsBundle_messageType) New() protoreflect.Message {
	return new(fastReflection_BlobsBundle)
}
func (x fastReflection_BlobsBundle_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_BlobsBundle
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_BlobsBundle) Descriptor() protoreflect.MessageDescriptor {
	return md_BlobsBundle
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_BlobsBundle) Type() protoreflect.MessageType {
	return _fastReflection_BlobsBundle_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_BlobsBundle) New() protoreflect.Message {
	return new(fastReflection_BlobsBundle)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_BlobsBundle) Interface() protoreflect.ProtoMessage {
	return (*BlobsBundle)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_BlobsBundle) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.KzgCommitments) != 0 {
		value := protoreflect.ValueOfList(&_BlobsBundle_1_list{list: &x.KzgCommitments})
		if !f(fd_BlobsBundle_kzg_commitments, value) {
			return
		}
	}
	if len(x.Proofs) != 0 {
		value := protoreflect.ValueOfList(&_BlobsBundle_2_list{list: &x.Proofs})
		if !f(fd_BlobsBundle_proofs, value) {
			return
		}
	}
	if len(x.Blobs) != 0 {
		value := protoreflect.ValueOfList(&_BlobsBundle_3_list{list: &x.Blobs})
		if !f(fd_BlobsBundle_blobs, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_BlobsBundle) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		return len(x.KzgCommitments) != 0
	case "ethereum.engine.v1.BlobsBundle.proofs":
		return len(x.Proofs) != 0
	case "ethereum.engine.v1.BlobsBundle.blobs":
		return len(x.Blobs) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BlobsBundle) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		x.KzgCommitments = nil
	case "ethereum.engine.v1.BlobsBundle.proofs":
		x.Proofs = nil
	case "ethereum.engine.v1.BlobsBundle.blobs":
		x.Blobs = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_BlobsBundle) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		if len(x.KzgCommitments) == 0 {
			return protoreflect.ValueOfList(&_BlobsBundle_1_list{})
		}
		listValue := &_BlobsBundle_1_list{list: &x.KzgCommitments}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.BlobsBundle.proofs":
		if len(x.Proofs) == 0 {
			return protoreflect.ValueOfList(&_BlobsBundle_2_list{})
		}
		listValue := &_BlobsBundle_2_list{list: &x.Proofs}
		return protoreflect.ValueOfList(listValue)
	case "ethereum.engine.v1.BlobsBundle.blobs":
		if len(x.Blobs) == 0 {
			return protoreflect.ValueOfList(&_BlobsBundle_3_list{})
		}
		listValue := &_BlobsBundle_3_list{list: &x.Blobs}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BlobsBundle) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		lv := value.List()
		clv := lv.(*_BlobsBundle_1_list)
		x.KzgCommitments = *clv.list
	case "ethereum.engine.v1.BlobsBundle.proofs":
		lv := value.List()
		clv := lv.(*_BlobsBundle_2_list)
		x.Proofs = *clv.list
	case "ethereum.engine.v1.BlobsBundle.blobs":
		lv := value.List()
		clv := lv.(*_BlobsBundle_3_list)
		x.Blobs = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BlobsBundle) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		if x.KzgCommitments == nil {
			x.KzgCommitments = [][]byte{}
		}
		value := &_BlobsBundle_1_list{list: &x.KzgCommitments}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.BlobsBundle.proofs":
		if x.Proofs == nil {
			x.Proofs = [][]byte{}
		}
		value := &_BlobsBundle_2_list{list: &x.Proofs}
		return protoreflect.ValueOfList(value)
	case "ethereum.engine.v1.BlobsBundle.blobs":
		if x.Blobs == nil {
			x.Blobs = [][]byte{}
		}
		value := &_BlobsBundle_3_list{list: &x.Blobs}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_BlobsBundle) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.BlobsBundle.kzg_commitments":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_BlobsBundle_1_list{list: &list})
	case "ethereum.engine.v1.BlobsBundle.proofs":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_BlobsBundle_2_list{list: &list})
	case "ethereum.engine.v1.BlobsBundle.blobs":
		list := [][]byte{}
		return protoreflect.ValueOfList(&_BlobsBundle_3_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.BlobsBundle"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.BlobsBundle does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_BlobsBundle) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.BlobsBundle", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_BlobsBundle) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BlobsBundle) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_BlobsBundle) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_BlobsBundle) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*BlobsBundle)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.KzgCommitments) > 0 {
			for _, b := range x.KzgCommitments {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Proofs) > 0 {
			for _, b := range x.Proofs {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Blobs) > 0 {
			for _, b := range x.Blobs {
				l = len(b)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*BlobsBundle)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Blobs) > 0 {
			for iNdEx := len(x.Blobs) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Blobs[iNdEx])
				copy(dAtA[i:], x.Blobs[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Blobs[iNdEx])))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.Proofs) > 0 {
			for iNdEx := len(x.Proofs) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Proofs[iNdEx])
				copy(dAtA[i:], x.Proofs[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Proofs[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.KzgCommitments) > 0 {
			for iNdEx := len(x.KzgCommitments) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.KzgCommitments[iNdEx])
				copy(dAtA[i:], x.KzgCommitments[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.KzgCommitments[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*BlobsBundle)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BlobsBundle: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BlobsBundle: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field KzgCommitments", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.KzgCommitments = append(x.KzgCommitments, make([]byte, postIndex-iNdEx))
				copy(x.KzgCommitments[len(x.KzgCommitments)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Proofs = append(x.Proofs, make([]byte, postIndex-iNdEx))
				copy(x.Proofs[len(x.Proofs)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Blobs = append(x.Blobs, make([]byte, postIndex-iNdEx))
				copy(x.Blobs[len(x.Blobs)-1], dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_Blob      protoreflect.MessageDescriptor
	fd_Blob_data protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_Blob = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("Blob")
	fd_Blob_data = md_Blob.Fields().ByName("data")
}

var _ protoreflect.Message = (*fastReflection_Blob)(nil)

type fastReflection_Blob Blob

func (x *Blob) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Blob)(x)
}

func (x *Blob) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Blob_messageType fastReflection_Blob_messageType
var _ protoreflect.MessageType = fastReflection_Blob_messageType{}

type fastReflection_Blob_messageType struct{}

func (x fastReflection_Blob_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Blob)(nil)
}
func (x fastReflection_Blob_messageType) New() protoreflect.Message {
	return new(fastReflection_Blob)
}
func (x fastReflection_Blob_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Blob
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Blob) Descriptor() protoreflect.MessageDescriptor {
	return md_Blob
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Blob) Type() protoreflect.MessageType {
	return _fastReflection_Blob_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Blob) New() protoreflect.Message {
	return new(fastReflection_Blob)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Blob) Interface() protoreflect.ProtoMessage {
	return (*Blob)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Blob) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Data) != 0 {
		value := protoreflect.ValueOfBytes(x.Data)
		if !f(fd_Blob_data, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Blob) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.Blob.data":
		return len(x.Data) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Blob) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.Blob.data":
		x.Data = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Blob) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.Blob.data":
		value := x.Data
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Blob) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.Blob.data":
		x.Data = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Blob) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.Blob.data":
		panic(fmt.Errorf("field data of message ethereum.engine.v1.Blob is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Blob) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.Blob.data":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.Blob"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.Blob does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Blob) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.Blob", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Blob) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Blob) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Blob) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Blob) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Blob)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Data)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Blob)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Data) > 0 {
			i -= len(x.Data)
			copy(dAtA[i:], x.Data)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Data)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Blob)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Blob: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Blob: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Data = append(x.Data[:0], dAtA[iNdEx:postIndex]...)
				if x.Data == nil {
					x.Data = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ExchangeCapabilities_1_list)(nil)

type _ExchangeCapabilities_1_list struct {
	list *[]string
}

func (x *_ExchangeCapabilities_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ExchangeCapabilities_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_ExchangeCapabilities_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_ExchangeCapabilities_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_ExchangeCapabilities_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message ExchangeCapabilities at list field SupportedMethods as it is not of Message kind"))
}

func (x *_ExchangeCapabilities_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_ExchangeCapabilities_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_ExchangeCapabilities_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ExchangeCapabilities                   protoreflect.MessageDescriptor
	fd_ExchangeCapabilities_supported_methods protoreflect.FieldDescriptor
)

func init() {
	file_ethereum_engine_v1_execution_engine_proto_init()
	md_ExchangeCapabilities = File_ethereum_engine_v1_execution_engine_proto.Messages().ByName("ExchangeCapabilities")
	fd_ExchangeCapabilities_supported_methods = md_ExchangeCapabilities.Fields().ByName("supported_methods")
}

var _ protoreflect.Message = (*fastReflection_ExchangeCapabilities)(nil)

type fastReflection_ExchangeCapabilities ExchangeCapabilities

func (x *ExchangeCapabilities) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ExchangeCapabilities)(x)
}

func (x *ExchangeCapabilities) slowProtoReflect() protoreflect.Message {
	mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ExchangeCapabilities_messageType fastReflection_ExchangeCapabilities_messageType
var _ protoreflect.MessageType = fastReflection_ExchangeCapabilities_messageType{}

type fastReflection_ExchangeCapabilities_messageType struct{}

func (x fastReflection_ExchangeCapabilities_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ExchangeCapabilities)(nil)
}
func (x fastReflection_ExchangeCapabilities_messageType) New() protoreflect.Message {
	return new(fastReflection_ExchangeCapabilities)
}
func (x fastReflection_ExchangeCapabilities_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ExchangeCapabilities
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ExchangeCapabilities) Descriptor() protoreflect.MessageDescriptor {
	return md_ExchangeCapabilities
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ExchangeCapabilities) Type() protoreflect.MessageType {
	return _fastReflection_ExchangeCapabilities_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ExchangeCapabilities) New() protoreflect.Message {
	return new(fastReflection_ExchangeCapabilities)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ExchangeCapabilities) Interface() protoreflect.ProtoMessage {
	return (*ExchangeCapabilities)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ExchangeCapabilities) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.SupportedMethods) != 0 {
		value := protoreflect.ValueOfList(&_ExchangeCapabilities_1_list{list: &x.SupportedMethods})
		if !f(fd_ExchangeCapabilities_supported_methods, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ExchangeCapabilities) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		return len(x.SupportedMethods) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExchangeCapabilities) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		x.SupportedMethods = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ExchangeCapabilities) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		if len(x.SupportedMethods) == 0 {
			return protoreflect.ValueOfList(&_ExchangeCapabilities_1_list{})
		}
		listValue := &_ExchangeCapabilities_1_list{list: &x.SupportedMethods}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExchangeCapabilities) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		lv := value.List()
		clv := lv.(*_ExchangeCapabilities_1_list)
		x.SupportedMethods = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExchangeCapabilities) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		if x.SupportedMethods == nil {
			x.SupportedMethods = []string{}
		}
		value := &_ExchangeCapabilities_1_list{list: &x.SupportedMethods}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ExchangeCapabilities) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "ethereum.engine.v1.ExchangeCapabilities.supported_methods":
		list := []string{}
		return protoreflect.ValueOfList(&_ExchangeCapabilities_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: ethereum.engine.v1.ExchangeCapabilities"))
		}
		panic(fmt.Errorf("message ethereum.engine.v1.ExchangeCapabilities does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ExchangeCapabilities) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in ethereum.engine.v1.ExchangeCapabilities", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ExchangeCapabilities) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ExchangeCapabilities) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ExchangeCapabilities) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ExchangeCapabilities) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ExchangeCapabilities)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.SupportedMethods) > 0 {
			for _, s := range x.SupportedMethods {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ExchangeCapabilities)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SupportedMethods) > 0 {
			for iNdEx := len(x.SupportedMethods) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.SupportedMethods[iNdEx])
				copy(dAtA[i:], x.SupportedMethods[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SupportedMethods[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ExchangeCapabilities)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExchangeCapabilities: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ExchangeCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SupportedMethods", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SupportedMethods = append(x.SupportedMethods, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Copyright 2022 Prysmatic Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: ethereum/engine/v1/execution_engine.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PayloadStatus_Status int32

const (
	PayloadStatus_UNKNOWN            PayloadStatus_Status = 0
	PayloadStatus_VALID              PayloadStatus_Status = 1
	PayloadStatus_INVALID            PayloadStatus_Status = 2
	PayloadStatus_SYNCING            PayloadStatus_Status = 3
	PayloadStatus_ACCEPTED           PayloadStatus_Status = 4
	PayloadStatus_INVALID_BLOCK_HASH PayloadStatus_Status = 5
)

// Enum value maps for PayloadStatus_Status.
var (
	PayloadStatus_Status_name = map[int32]string{
		0: "UNKNOWN",
		1: "VALID",
		2: "INVALID",
		3: "SYNCING",
		4: "ACCEPTED",
		5: "INVALID_BLOCK_HASH",
	}
	PayloadStatus_Status_value = map[string]int32{
		"UNKNOWN":            0,
		"VALID":              1,
		"INVALID":            2,
		"SYNCING":            3,
		"ACCEPTED":           4,
		"INVALID_BLOCK_HASH": 5,
	}
)

func (x PayloadStatus_Status) Enum() *PayloadStatus_Status {
	p := new(PayloadStatus_Status)
	*p = x
	return p
}

func (x PayloadStatus_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayloadStatus_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_ethereum_engine_v1_execution_engine_proto_enumTypes[0].Descriptor()
}

func (PayloadStatus_Status) Type() protoreflect.EnumType {
	return &file_ethereum_engine_v1_execution_engine_proto_enumTypes[0]
}

func (x PayloadStatus_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayloadStatus_Status.Descriptor instead.
func (PayloadStatus_Status) EnumDescriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{12, 0}
}

type ExecutionPayload struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash    []byte   `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient  []byte   `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot     []byte   `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot  []byte   `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom     []byte   `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao    []byte   `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber   uint64   `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit      uint64   `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed       uint64   `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp     uint64   `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData     []byte   `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas []byte   `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash     []byte   `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Transactions  [][]byte `protobuf:"bytes,14,rep,name=transactions,proto3" json:"transactions,omitempty"`
}

func (x *ExecutionPayload) Reset() {
	*x = ExecutionPayload{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayload) ProtoMessage() {}

// Deprecated: Use ExecutionPayload.ProtoReflect.Descriptor instead.
func (*ExecutionPayload) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{0}
}

func (x *ExecutionPayload) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayload) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayload) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayload) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayload) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayload) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayload) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayload) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayload) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayload) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayload) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayload) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayload) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayload) GetTransactions() [][]byte {
	if x != nil {
		return x.Transactions
	}
	return nil
}

type ExecutionPayloadBodyV1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Transactions [][]byte      `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	Withdrawals  []*Withdrawal `protobuf:"bytes,2,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"`
}

func (x *ExecutionPayloadBodyV1) Reset() {
	*x = ExecutionPayloadBodyV1{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadBodyV1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadBodyV1) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadBodyV1.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadBodyV1) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{1}
}

func (x *ExecutionPayloadBodyV1) GetTransactions() [][]byte {
	if x != nil {
		return x.Transactions
	}
	return nil
}

func (x *ExecutionPayloadBodyV1) GetWithdrawals() []*Withdrawal {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

type ExecutionPayloadCapella struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash    []byte   `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient  []byte   `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot     []byte   `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot  []byte   `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom     []byte   `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao    []byte   `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber   uint64   `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit      uint64   `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed       uint64   `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp     uint64   `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData     []byte   `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas []byte   `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash     []byte   `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Transactions  [][]byte `protobuf:"bytes,14,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// MAX_WITHDRAWALS_PER_PAYLOAD
	Withdrawals []*Withdrawal `protobuf:"bytes,15,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"` // New in Capella.
}

func (x *ExecutionPayloadCapella) Reset() {
	*x = ExecutionPayloadCapella{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadCapella) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadCapella) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadCapella.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadCapella) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{2}
}

func (x *ExecutionPayloadCapella) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayloadCapella) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayloadCapella) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayloadCapella) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayloadCapella) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetTransactions() [][]byte {
	if x != nil {
		return x.Transactions
	}
	return nil
}

func (x *ExecutionPayloadCapella) GetWithdrawals() []*Withdrawal {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

type ExecutionPayloadDeneb struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash    []byte   `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient  []byte   `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot     []byte   `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot  []byte   `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom     []byte   `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao    []byte   `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber   uint64   `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit      uint64   `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed       uint64   `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp     uint64   `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData     []byte   `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas []byte   `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash     []byte   `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Transactions  [][]byte `protobuf:"bytes,14,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// MAX_WITHDRAWALS_PER_PAYLOAD
	Withdrawals   []*Withdrawal `protobuf:"bytes,15,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"`
	BlobGasUsed   uint64        `protobuf:"varint,16,opt,name=blob_gas_used,json=blobGasUsed,proto3" json:"blob_gas_used,omitempty"`
	ExcessBlobGas uint64        `protobuf:"varint,17,opt,name=excess_blob_gas,json=excessBlobGas,proto3" json:"excess_blob_gas,omitempty"`
}

func (x *ExecutionPayloadDeneb) Reset() {
	*x = ExecutionPayloadDeneb{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadDeneb) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadDeneb) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadDeneb.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadDeneb) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{3}
}

func (x *ExecutionPayloadDeneb) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayloadDeneb) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayloadDeneb) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayloadDeneb) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayloadDeneb) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetTransactions() [][]byte {
	if x != nil {
		return x.Transactions
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetWithdrawals() []*Withdrawal {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

func (x *ExecutionPayloadDeneb) GetBlobGasUsed() uint64 {
	if x != nil {
		return x.BlobGasUsed
	}
	return 0
}

func (x *ExecutionPayloadDeneb) GetExcessBlobGas() uint64 {
	if x != nil {
		return x.ExcessBlobGas
	}
	return 0
}

type ExecutionPayloadCapellaWithValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Payload *ExecutionPayloadCapella `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Value   []byte                   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *ExecutionPayloadCapellaWithValue) Reset() {
	*x = ExecutionPayloadCapellaWithValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadCapellaWithValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadCapellaWithValue) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadCapellaWithValue.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadCapellaWithValue) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{4}
}

func (x *ExecutionPayloadCapellaWithValue) GetPayload() *ExecutionPayloadCapella {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ExecutionPayloadCapellaWithValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type ExecutionPayloadDenebWithValueAndBlobsBundle struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Payload               *ExecutionPayloadDeneb `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Value                 []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	BlobsBundle           *BlobsBundle           `protobuf:"bytes,3,opt,name=blobs_bundle,json=blobsBundle,proto3" json:"blobs_bundle,omitempty"`
	ShouldOverrideBuilder bool                   `protobuf:"varint,4,opt,name=should_override_builder,json=shouldOverrideBuilder,proto3" json:"should_override_builder,omitempty"`
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) Reset() {
	*x = ExecutionPayloadDenebWithValueAndBlobsBundle{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadDenebWithValueAndBlobsBundle) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadDenebWithValueAndBlobsBundle.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadDenebWithValueAndBlobsBundle) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{5}
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) GetPayload() *ExecutionPayloadDeneb {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) GetBlobsBundle() *BlobsBundle {
	if x != nil {
		return x.BlobsBundle
	}
	return nil
}

func (x *ExecutionPayloadDenebWithValueAndBlobsBundle) GetShouldOverrideBuilder() bool {
	if x != nil {
		return x.ShouldOverrideBuilder
	}
	return false
}

type ExecutionPayloadHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash       []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient     []byte `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot        []byte `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot     []byte `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom        []byte `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao       []byte `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber      uint64 `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit         uint64 `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed          uint64 `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp        uint64 `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData        []byte `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas    []byte `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash        []byte `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	TransactionsRoot []byte `protobuf:"bytes,14,opt,name=transactions_root,json=transactionsRoot,proto3" json:"transactions_root,omitempty"`
}

func (x *ExecutionPayloadHeader) Reset() {
	*x = ExecutionPayloadHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadHeader) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadHeader.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadHeader) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{6}
}

func (x *ExecutionPayloadHeader) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayloadHeader) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayloadHeader) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayloadHeader) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayloadHeader) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayloadHeader) GetTransactionsRoot() []byte {
	if x != nil {
		return x.TransactionsRoot
	}
	return nil
}

type ExecutionPayloadHeaderCapella struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash       []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient     []byte `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot        []byte `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot     []byte `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom        []byte `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao       []byte `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber      uint64 `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit         uint64 `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed          uint64 `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp        uint64 `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData        []byte `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas    []byte `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash        []byte `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	TransactionsRoot []byte `protobuf:"bytes,14,opt,name=transactions_root,json=transactionsRoot,proto3" json:"transactions_root,omitempty"`
	WithdrawalsRoot  []byte `protobuf:"bytes,15,opt,name=withdrawals_root,json=withdrawalsRoot,proto3" json:"withdrawals_root,omitempty"` // New in Capella.
}

func (x *ExecutionPayloadHeaderCapella) Reset() {
	*x = ExecutionPayloadHeaderCapella{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadHeaderCapella) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadHeaderCapella) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadHeaderCapella.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadHeaderCapella) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{7}
}

func (x *ExecutionPayloadHeaderCapella) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayloadHeaderCapella) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayloadHeaderCapella) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayloadHeaderCapella) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayloadHeaderCapella) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetTransactionsRoot() []byte {
	if x != nil {
		return x.TransactionsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderCapella) GetWithdrawalsRoot() []byte {
	if x != nil {
		return x.WithdrawalsRoot
	}
	return nil
}

type ExecutionPayloadHeaderDeneb struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ParentHash       []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	FeeRecipient     []byte `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	StateRoot        []byte `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot     []byte `protobuf:"bytes,4,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	LogsBloom        []byte `protobuf:"bytes,5,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	PrevRandao       []byte `protobuf:"bytes,6,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	BlockNumber      uint64 `protobuf:"varint,7,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasLimit         uint64 `protobuf:"varint,8,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed          uint64 `protobuf:"varint,9,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp        uint64 `protobuf:"varint,10,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ExtraData        []byte `protobuf:"bytes,11,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BaseFeePerGas    []byte `protobuf:"bytes,12,opt,name=base_fee_per_gas,json=baseFeePerGas,proto3" json:"base_fee_per_gas,omitempty"`
	BlockHash        []byte `protobuf:"bytes,13,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	TransactionsRoot []byte `protobuf:"bytes,14,opt,name=transactions_root,json=transactionsRoot,proto3" json:"transactions_root,omitempty"`
	WithdrawalsRoot  []byte `protobuf:"bytes,15,opt,name=withdrawals_root,json=withdrawalsRoot,proto3" json:"withdrawals_root,omitempty"`
	BlobGasUsed      uint64 `protobuf:"varint,16,opt,name=blob_gas_used,json=blobGasUsed,proto3" json:"blob_gas_used,omitempty"`
	ExcessBlobGas    uint64 `protobuf:"varint,17,opt,name=excess_blob_gas,json=excessBlobGas,proto3" json:"excess_blob_gas,omitempty"`
}

func (x *ExecutionPayloadHeaderDeneb) Reset() {
	*x = ExecutionPayloadHeaderDeneb{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecutionPayloadHeaderDeneb) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionPayloadHeaderDeneb) ProtoMessage() {}

// Deprecated: Use ExecutionPayloadHeaderDeneb.ProtoReflect.Descriptor instead.
func (*ExecutionPayloadHeaderDeneb) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{8}
}

func (x *ExecutionPayloadHeaderDeneb) GetParentHash() []byte {
	if x != nil {
		return x.ParentHash
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetFeeRecipient() []byte {
	if x != nil {
		return x.FeeRecipient
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetStateRoot() []byte {
	if x != nil {
		return x.StateRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetReceiptsRoot() []byte {
	if x != nil {
		return x.ReceiptsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetLogsBloom() []byte {
	if x != nil {
		return x.LogsBloom
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *ExecutionPayloadHeaderDeneb) GetGasLimit() uint64 {
	if x != nil {
		return x.GasLimit
	}
	return 0
}

func (x *ExecutionPayloadHeaderDeneb) GetGasUsed() uint64 {
	if x != nil {
		return x.GasUsed
	}
	return 0
}

func (x *ExecutionPayloadHeaderDeneb) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ExecutionPayloadHeaderDeneb) GetExtraData() []byte {
	if x != nil {
		return x.ExtraData
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetBaseFeePerGas() []byte {
	if x != nil {
		return x.BaseFeePerGas
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetTransactionsRoot() []byte {
	if x != nil {
		return x.TransactionsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetWithdrawalsRoot() []byte {
	if x != nil {
		return x.WithdrawalsRoot
	}
	return nil
}

func (x *ExecutionPayloadHeaderDeneb) GetBlobGasUsed() uint64 {
	if x != nil {
		return x.BlobGasUsed
	}
	return 0
}

func (x *ExecutionPayloadHeaderDeneb) GetExcessBlobGas() uint64 {
	if x != nil {
		return x.ExcessBlobGas
	}
	return 0
}

type PayloadAttributes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Timestamp             uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	PrevRandao            []byte `protobuf:"bytes,2,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	SuggestedFeeRecipient []byte `protobuf:"bytes,3,opt,name=suggested_fee_recipient,json=suggestedFeeRecipient,proto3" json:"suggested_fee_recipient,omitempty"`
}

func (x *PayloadAttributes) Reset() {
	*x = PayloadAttributes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PayloadAttributes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayloadAttributes) ProtoMessage() {}

// Deprecated: Use PayloadAttributes.ProtoReflect.Descriptor instead.
func (*PayloadAttributes) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{9}
}

func (x *PayloadAttributes) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PayloadAttributes) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *PayloadAttributes) GetSuggestedFeeRecipient() []byte {
	if x != nil {
		return x.SuggestedFeeRecipient
	}
	return nil
}

type PayloadAttributesV2 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Timestamp             uint64        `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	PrevRandao            []byte        `protobuf:"bytes,2,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	SuggestedFeeRecipient []byte        `protobuf:"bytes,3,opt,name=suggested_fee_recipient,json=suggestedFeeRecipient,proto3" json:"suggested_fee_recipient,omitempty"`
	Withdrawals           []*Withdrawal `protobuf:"bytes,4,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"` // New in Capella.
}

func (x *PayloadAttributesV2) Reset() {
	*x = PayloadAttributesV2{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PayloadAttributesV2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayloadAttributesV2) ProtoMessage() {}

// Deprecated: Use PayloadAttributesV2.ProtoReflect.Descriptor instead.
func (*PayloadAttributesV2) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{10}
}

func (x *PayloadAttributesV2) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PayloadAttributesV2) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *PayloadAttributesV2) GetSuggestedFeeRecipient() []byte {
	if x != nil {
		return x.SuggestedFeeRecipient
	}
	return nil
}

func (x *PayloadAttributesV2) GetWithdrawals() []*Withdrawal {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

type PayloadAttributesV3 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Timestamp             uint64        `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	PrevRandao            []byte        `protobuf:"bytes,2,opt,name=prev_randao,json=prevRandao,proto3" json:"prev_randao,omitempty"`
	SuggestedFeeRecipient []byte        `protobuf:"bytes,3,opt,name=suggested_fee_recipient,json=suggestedFeeRecipient,proto3" json:"suggested_fee_recipient,omitempty"`
	Withdrawals           []*Withdrawal `protobuf:"bytes,4,rep,name=withdrawals,proto3" json:"withdrawals,omitempty"`
	ParentBeaconBlockRoot []byte        `protobuf:"bytes,5,opt,name=parent_beacon_block_root,json=parentBeaconBlockRoot,proto3" json:"parent_beacon_block_root,omitempty"`
}

func (x *PayloadAttributesV3) Reset() {
	*x = PayloadAttributesV3{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PayloadAttributesV3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayloadAttributesV3) ProtoMessage() {}

// Deprecated: Use PayloadAttributesV3.ProtoReflect.Descriptor instead.
func (*PayloadAttributesV3) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{11}
}

func (x *PayloadAttributesV3) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PayloadAttributesV3) GetPrevRandao() []byte {
	if x != nil {
		return x.PrevRandao
	}
	return nil
}

func (x *PayloadAttributesV3) GetSuggestedFeeRecipient() []byte {
	if x != nil {
		return x.SuggestedFeeRecipient
	}
	return nil
}

func (x *PayloadAttributesV3) GetWithdrawals() []*Withdrawal {
	if x != nil {
		return x.Withdrawals
	}
	return nil
}

func (x *PayloadAttributesV3) GetParentBeaconBlockRoot() []byte {
	if x != nil {
		return x.ParentBeaconBlockRoot
	}
	return nil
}

type PayloadStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status          PayloadStatus_Status `protobuf:"varint,1,opt,name=status,proto3,enum=ethereum.engine.v1.PayloadStatus_Status" json:"status,omitempty"`
	LatestValidHash []byte               `protobuf:"bytes,2,opt,name=latest_valid_hash,json=latestValidHash,proto3" json:"latest_valid_hash,omitempty"`
	ValidationError string               `protobuf:"bytes,3,opt,name=validation_error,json=validationError,proto3" json:"validation_error,omitempty"`
}

func (x *PayloadStatus) Reset() {
	*x = PayloadStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PayloadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayloadStatus) ProtoMessage() {}

// Deprecated: Use PayloadStatus.ProtoReflect.Descriptor instead.
func (*PayloadStatus) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{12}
}

func (x *PayloadStatus) GetStatus() PayloadStatus_Status {
	if x != nil {
		return x.Status
	}
	return PayloadStatus_UNKNOWN
}

func (x *PayloadStatus) GetLatestValidHash() []byte {
	if x != nil {
		return x.LatestValidHash
	}
	return nil
}

func (x *PayloadStatus) GetValidationError() string {
	if x != nil {
		return x.ValidationError
	}
	return ""
}

type ForkchoiceState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	HeadBlockHash      []byte `protobuf:"bytes,1,opt,name=head_block_hash,json=headBlockHash,proto3" json:"head_block_hash,omitempty"`
	SafeBlockHash      []byte `protobuf:"bytes,2,opt,name=safe_block_hash,json=safeBlockHash,proto3" json:"safe_block_hash,omitempty"`
	FinalizedBlockHash []byte `protobuf:"bytes,3,opt,name=finalized_block_hash,json=finalizedBlockHash,proto3" json:"finalized_block_hash,omitempty"`
}

func (x *ForkchoiceState) Reset() {
	*x = ForkchoiceState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ForkchoiceState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ForkchoiceState) ProtoMessage() {}

// Deprecated: Use ForkchoiceState.ProtoReflect.Descriptor instead.
func (*ForkchoiceState) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{13}
}

func (x *ForkchoiceState) GetHeadBlockHash() []byte {
	if x != nil {
		return x.HeadBlockHash
	}
	return nil
}

func (x *ForkchoiceState) GetSafeBlockHash() []byte {
	if x != nil {
		return x.SafeBlockHash
	}
	return nil
}

func (x *ForkchoiceState) GetFinalizedBlockHash() []byte {
	if x != nil {
		return x.FinalizedBlockHash
	}
	return nil
}

// The withdrawal receipt with the recipient address and amount withdrawn
type Withdrawal struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Withdrawal index for accounting purposes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// Validator index for the withdrawal
	ValidatorIndex uint64 `protobuf:"varint,2,opt,name=validator_index,json=validatorIndex,proto3" json:"validator_index,omitempty"`
	// The execution address receiving the funds
	Address []byte `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The withdrawn amount in Gwei
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *Withdrawal) Reset() {
	*x = Withdrawal{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Withdrawal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Withdrawal) ProtoMessage() {}

// Deprecated: Use Withdrawal.ProtoReflect.Descriptor instead.
func (*Withdrawal) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{14}
}

func (x *Withdrawal) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *Withdrawal) GetValidatorIndex() uint64 {
	if x != nil {
		return x.ValidatorIndex
	}
	return 0
}

func (x *Withdrawal) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *Withdrawal) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

// BlobsBundle is retrieved through engine-api from the execution layer client.
// It consists of the necessary components for constructing a blobs sidecar object to gossip through p2p.
type BlobsBundle struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The KZG commitments of the blobs.
	KzgCommitments [][]byte `protobuf:"bytes,1,rep,name=kzg_commitments,json=kzgCommitments,proto3" json:"kzg_commitments,omitempty"`
	// The proofs of the blobs.
	Proofs [][]byte `protobuf:"bytes,2,rep,name=proofs,proto3" json:"proofs,omitempty"`
	// The blobs itself.
	Blobs [][]byte `protobuf:"bytes,3,rep,name=blobs,proto3" json:"blobs,omitempty"`
}

func (x *BlobsBundle) Reset() {
	*x = BlobsBundle{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BlobsBundle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlobsBundle) ProtoMessage() {}

// Deprecated: Use BlobsBundle.ProtoReflect.Descriptor instead.
func (*BlobsBundle) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{15}
}

func (x *BlobsBundle) GetKzgCommitments() [][]byte {
	if x != nil {
		return x.KzgCommitments
	}
	return nil
}

func (x *BlobsBundle) GetProofs() [][]byte {
	if x != nil {
		return x.Proofs
	}
	return nil
}

func (x *BlobsBundle) GetBlobs() [][]byte {
	if x != nil {
		return x.Blobs
	}
	return nil
}

// Blob contains the data that is to be committed on chain.
type Blob struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Each blob consists of `BLS_FIELD_ELEMENT`(32) multiplies `FIELD_ELEMENTS_PER_BLOB`(4096)
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *Blob) Reset() {
	*x = Blob{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Blob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Blob) ProtoMessage() {}

// Deprecated: Use Blob.ProtoReflect.Descriptor instead.
func (*Blob) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{16}
}

func (x *Blob) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type ExchangeCapabilities struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SupportedMethods []string `protobuf:"bytes,1,rep,name=supported_methods,json=supportedMethods,proto3" json:"supported_methods,omitempty"`
}

func (x *ExchangeCapabilities) Reset() {
	*x = ExchangeCapabilities{}
	if protoimpl.UnsafeEnabled {
		mi := &file_ethereum_engine_v1_execution_engine_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExchangeCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExchangeCapabilities) ProtoMessage() {}

// Deprecated: Use ExchangeCapabilities.ProtoReflect.Descriptor instead.
func (*ExchangeCapabilities) Descriptor() ([]byte, []int) {
	return file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP(), []int{17}
}

func (x *ExchangeCapabilities) GetSupportedMethods() []string {
	if x != nil {
		return x.SupportedMethods
	}
	return nil
}

var File_ethereum_engine_v1_execution_engine_proto protoreflect.FileDescriptor

var file_ethereum_engine_v1_execution_engine_proto_rawDesc = []byte{
	0x0a, 0x29, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2f, 0x65, 0x6e, 0x67, 0x69, 0x6e,
	0x65, 0x2f, 0x76, 0x31, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x65,
	0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x65, 0x74, 0x68,
	0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x1a,
	0x1e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2f, 0x65, 0x74, 0x68, 0x2f, 0x65, 0x78,
	0x74, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
	0xe1, 0x04, 0x0a, 0x10, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x68,
	0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33,
	0x32, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x2b, 0x0a,
	0x0d, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30, 0x52, 0x0c, 0x66, 0x65,
	0x65, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0a, 0x73, 0x74,
	0x61, 0x74, 0x65, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06,
	0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6f,
	0x74, 0x12, 0x2b, 0x0a, 0x0d, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x5f, 0x72, 0x6f,
	0x6f, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x32,
	0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x13, 0x8a, 0xb5, 0x18, 0x0f, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f,
	0x6f, 0x6d, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x73, 0x42, 0x6c, 0x6f,
	0x6f, 0x6d, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61,
	0x6f, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52,
	0x0a, 0x70, 0x72, 0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1b,
	0x0a, 0x09, 0x67, 0x61, 0x73, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x08, 0x67, 0x61, 0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67,
	0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x67,
	0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61,
	0x74, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x65, 0x78,
	0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x65,
	0x78, 0x74, 0x72, 0x61, 0x44, 0x61, 0x74, 0x61, 0x12, 0x2f, 0x0a, 0x10, 0x62, 0x61, 0x73, 0x65,
	0x5f, 0x66, 0x65, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x0c, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0d, 0x62, 0x61, 0x73, 0x65,
	0x46, 0x65, 0x65, 0x50, 0x65, 0x72, 0x47, 0x61, 0x73, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6c, 0x6f,
	0x63, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a,
	0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68,
	0x12, 0x41, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x18, 0x0e, 0x20, 0x03, 0x28, 0x0c, 0x42, 0x1d, 0x8a, 0xb5, 0x18, 0x03, 0x3f, 0x2c, 0x3f, 0x92,
	0xb5, 0x18, 0x12, 0x31, 0x30, 0x34, 0x38, 0x35, 0x37, 0x36, 0x2c, 0x31, 0x30, 0x37, 0x33, 0x37,
	0x34, 0x31, 0x38, 0x32, 0x34, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x22, 0x7e, 0x0a, 0x16, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x42, 0x6f, 0x64, 0x79, 0x56, 0x31, 0x12, 0x22, 0x0a,
	0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0c, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x12, 0x40, 0x0a, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75,
	0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x69, 0x74, 0x68,
	0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x61, 0x6c, 0x73, 0x22, 0xbf, 0x05, 0x0a, 0x17, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f,
	0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x61, 0x70, 0x65, 0x6c, 0x6c, 0x61, 0x12,
	0x27, 0x0a, 0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x2b, 0x0a, 0x0d, 0x66, 0x65, 0x65, 0x5f,
	0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30, 0x52, 0x0c, 0x66, 0x65, 0x65, 0x52, 0x65, 0x63, 0x69,
	0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72,
	0x6f, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33,
	0x32, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x2b, 0x0a, 0x0d,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0c, 0x72, 0x65, 0x63,
	0x65, 0x69, 0x70, 0x74, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x32, 0x0a, 0x0a, 0x6c, 0x6f, 0x67,
	0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x8a,
	0xb5, 0x18, 0x0f, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x2e, 0x73, 0x69,
	0x7a, 0x65, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x73, 0x42, 0x6c, 0x6f, 0x6f, 0x6d, 0x12, 0x27, 0x0a,
	0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x76,
	0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f,
	0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c,
	0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x61, 0x73,
	0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x67, 0x61,
	0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73,
	0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65,
	0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x32, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x44,
	0x61, 0x74, 0x61, 0x12, 0x2f, 0x0a, 0x10, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x65, 0x65, 0x5f,
	0x70, 0x65, 0x72, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a,
	0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x46, 0x65, 0x65, 0x50, 0x65,
	0x72, 0x47, 0x61, 0x73, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x09, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x12, 0x41, 0x0a, 0x0c, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28,
	0x0c, 0x42, 0x1d, 0x8a, 0xb5, 0x18, 0x03, 0x3f, 0x2c, 0x3f, 0x92, 0xb5, 0x18, 0x12, 0x31, 0x30,
	0x34, 0x38, 0x35, 0x37, 0x36, 0x2c, 0x31, 0x30, 0x37, 0x33, 0x37, 0x34, 0x31, 0x38, 0x32, 0x34,
	0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x55,
	0x0a, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x18, 0x0f, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e, 0x65,
	0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72,
	0x61, 0x77, 0x61, 0x6c, 0x73, 0x22, 0x89, 0x06, 0x0a, 0x15, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x44, 0x65, 0x6e, 0x65, 0x62, 0x12,
	0x27, 0x0a, 0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x61,
	0x72, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x2b, 0x0a, 0x0d, 0x66, 0x65, 0x65, 0x5f,
	0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30, 0x52, 0x0c, 0x66, 0x65, 0x65, 0x52, 0x65, 0x63, 0x69,
	0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72,
	0x6f, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33,
	0x32, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x2b, 0x0a, 0x0d,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0c, 0x72, 0x65, 0x63,
	0x65, 0x69, 0x70, 0x74, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x32, 0x0a, 0x0a, 0x6c, 0x6f, 0x67,
	0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x8a,
	0xb5, 0x18, 0x0f, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x2e, 0x73, 0x69,
	0x7a, 0x65, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x73, 0x42, 0x6c, 0x6f, 0x6f, 0x6d, 0x12, 0x27, 0x0a,
	0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x76,
	0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f,
	0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c,
	0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x61, 0x73,
	0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x67, 0x61,
	0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73,
	0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65,
	0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x32, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x44,
	0x61, 0x74, 0x61, 0x12, 0x2f, 0x0a, 0x10, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x65, 0x65, 0x5f,
	0x70, 0x65, 0x72, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a,
	0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x46, 0x65, 0x65, 0x50, 0x65,
	0x72, 0x47, 0x61, 0x73, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x09, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x12, 0x41, 0x0a, 0x0c, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28,
	0x0c, 0x42, 0x1d, 0x8a, 0xb5, 0x18, 0x03, 0x3f, 0x2c, 0x3f, 0x92, 0xb5, 0x18, 0x12, 0x31, 0x30,
	0x34, 0x38, 0x35, 0x37, 0x36, 0x2c, 0x31, 0x30, 0x37, 0x33, 0x37, 0x34, 0x31, 0x38, 0x32, 0x34,
	0x52, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x55,
	0x0a, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x18, 0x0f, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e, 0x65,
	0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72,
	0x61, 0x77, 0x61, 0x6c, 0x73, 0x12, 0x22, 0x0a, 0x0d, 0x62, 0x6c, 0x6f, 0x62, 0x5f, 0x67, 0x61,
	0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c,
	0x6f, 0x62, 0x47, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x0f, 0x65, 0x78, 0x63,
	0x65, 0x73, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x62, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x11, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0d, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x42, 0x6c, 0x6f, 0x62, 0x47, 0x61,
	0x73, 0x22, 0x7f, 0x0a, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x61, 0x70, 0x65, 0x6c, 0x6c, 0x61, 0x57, 0x69, 0x74, 0x68,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x45, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75,
	0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x61, 0x70, 0x65,
	0x6c, 0x6c, 0x61, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x22, 0x85, 0x02, 0x0a, 0x2c, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x44, 0x65, 0x6e, 0x65, 0x62, 0x57, 0x69, 0x74, 0x68,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x41, 0x6e, 0x64, 0x42, 0x6c, 0x6f, 0x62, 0x73, 0x42, 0x75, 0x6e,
	0x64, 0x6c, 0x65, 0x12, 0x43, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e,
	0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x44, 0x65, 0x6e, 0x65, 0x62, 0x52,
	0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x42,
	0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x5f, 0x62, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e,
	0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x6c, 0x6f, 0x62, 0x73, 0x42,
	0x75, 0x6e, 0x64, 0x6c, 0x65, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x42, 0x75, 0x6e, 0x64,
	0x6c, 0x65, 0x12, 0x36, 0x0a, 0x17, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x5f, 0x6f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x5f, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x65, 0x72, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x15, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x4f, 0x76, 0x65, 0x72, 0x72,
	0x69, 0x64, 0x65, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x65, 0x72, 0x22, 0xd9, 0x04, 0x0a, 0x16, 0x45,
	0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x48,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f,
	0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02,
	0x33, 0x32, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x2b,
	0x0a, 0x0d, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30, 0x52, 0x0c, 0x66,
	0x65, 0x65, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0a, 0x73,
	0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x6f,
	0x6f, 0x74, 0x12, 0x2b, 0x0a, 0x0d, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x5f, 0x72,
	0x6f, 0x6f, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33,
	0x32, 0x52, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12,
	0x32, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x13, 0x8a, 0xb5, 0x18, 0x0f, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c,
	0x6f, 0x6f, 0x6d, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x6c, 0x6f, 0x67, 0x73, 0x42, 0x6c,
	0x6f, 0x6f, 0x6d, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64,
	0x61, 0x6f, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x0a, 0x70, 0x72, 0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x21, 0x0a, 0x0c,
	0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12,
	0x1b, 0x0a, 0x09, 0x67, 0x61, 0x73, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x08, 0x67, 0x61, 0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08,
	0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07,
	0x67, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64,
	0x61, 0x74, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x65,
	0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09,
	0x65, 0x78, 0x74, 0x72, 0x61, 0x44, 0x61, 0x74, 0x61, 0x12, 0x2f, 0x0a, 0x10, 0x62, 0x61, 0x73,
	0x65, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0d, 0x62, 0x61, 0x73,
	0x65, 0x46, 0x65, 0x65, 0x50, 0x65, 0x72, 0x47, 0x61, 0x73, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6c,
	0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06,
	0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73,
	0x68, 0x12, 0x33, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5,
	0x18, 0x02, 0x33, 0x32, 0x52, 0x10, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x22, 0x93, 0x05, 0x0a, 0x1d, 0x45, 0x78, 0x65, 0x63, 0x75,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x48, 0x65, 0x61, 0x64, 0x65,
	0x72, 0x43, 0x61, 0x70, 0x65, 0x6c, 0x6c, 0x61, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x61, 0x72, 0x65,
	0x6e, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a,
	0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x48, 0x61, 0x73,
	0x68, 0x12, 0x2b, 0x0a, 0x0d, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65,
	0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30,
	0x52, 0x0c, 0x66, 0x65, 0x65, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x25,
	0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x2b, 0x0a, 0x0d, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74,
	0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5,
	0x18, 0x02, 0x33, 0x32, 0x52, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70, 0x74, 0x73, 0x52, 0x6f,
	0x6f, 0x74, 0x12, 0x32, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x8a, 0xb5, 0x18, 0x0f, 0x6c, 0x6f, 0x67, 0x73,
	0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x6c, 0x6f, 0x67,
	0x73, 0x42, 0x6c, 0x6f, 0x6f, 0x6d, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72,
	0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18,
	0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12,
	0x21, 0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62,
	0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x61, 0x73, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x67, 0x61, 0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12,
	0x19, 0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72,
	0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x92, 0xb5,
	0x18, 0x0f, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x73, 0x69, 0x7a,
	0x65, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x44, 0x61, 0x74, 0x61, 0x12, 0x2f, 0x0a, 0x10,
	0x62, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x67, 0x61, 0x73,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0d,
	0x62, 0x61, 0x73, 0x65, 0x46, 0x65, 0x65, 0x50, 0x65, 0x72, 0x47, 0x61, 0x73, 0x12, 0x25, 0x0a,
	0x0a, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
	0x48, 0x61, 0x73, 0x68, 0x12, 0x33, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x10, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x31, 0x0a, 0x10, 0x77, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x0f, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0f, 0x77, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x22, 0xdd, 0x05, 0x0a,
	0x1b, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61,
	0x64, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x44, 0x65, 0x6e, 0x65, 0x62, 0x12, 0x27, 0x0a, 0x0b,
	0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x65, 0x6e,
	0x74, 0x48, 0x61, 0x73, 0x68, 0x12, 0x2b, 0x0a, 0x0d, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63,
	0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5,
	0x18, 0x02, 0x32, 0x30, 0x52, 0x0c, 0x66, 0x65, 0x65, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65,
	0x6e, 0x74, 0x12, 0x25, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x6f, 0x6f, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09,
	0x73, 0x74, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x2b, 0x0a, 0x0d, 0x72, 0x65, 0x63,
	0x65, 0x69, 0x70, 0x74, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c,
	0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x69, 0x70,
	0x74, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x32, 0x0a, 0x0a, 0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62,
	0x6c, 0x6f, 0x6f, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x13, 0x8a, 0xb5, 0x18, 0x0f,
	0x6c, 0x6f, 0x67, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x6d, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52,
	0x09, 0x6c, 0x6f, 0x67, 0x73, 0x42, 0x6c, 0x6f, 0x6f, 0x6d, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72,
	0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x76, 0x52, 0x61, 0x6e,
	0x64, 0x61, 0x6f, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
	0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x61, 0x73, 0x5f, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x67, 0x61, 0x73, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x67, 0x61, 0x73, 0x55, 0x73, 0x65, 0x64, 0x12, 0x1c,
	0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x32, 0x0a, 0x0a,
	0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c,
	0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61,
	0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x09, 0x65, 0x78, 0x74, 0x72, 0x61, 0x44, 0x61, 0x74, 0x61,
	0x12, 0x2f, 0x0a, 0x10, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x70, 0x65, 0x72,
	0x5f, 0x67, 0x61, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02,
	0x33, 0x32, 0x52, 0x0d, 0x62, 0x61, 0x73, 0x65, 0x46, 0x65, 0x65, 0x50, 0x65, 0x72, 0x47, 0x61,
	0x73, 0x12, 0x25, 0x0a, 0x0a, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x09, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x12, 0x33, 0x0a, 0x11, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x0e, 0x20,
	0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x10, 0x74, 0x72, 0x61,
	0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x6f, 0x6f, 0x74, 0x12, 0x31, 0x0a,
	0x10, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x5f, 0x72, 0x6f, 0x6f,
	0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52,
	0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x52, 0x6f, 0x6f, 0x74,
	0x12, 0x22, 0x0a, 0x0d, 0x62, 0x6c, 0x6f, 0x62, 0x5f, 0x67, 0x61, 0x73, 0x5f, 0x75, 0x73, 0x65,
	0x64, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x62, 0x47, 0x61, 0x73,
	0x55, 0x73, 0x65, 0x64, 0x12, 0x26, 0x0a, 0x0f, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x62,
	0x6c, 0x6f, 0x62, 0x5f, 0x67, 0x61, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x65,
	0x78, 0x63, 0x65, 0x73, 0x73, 0x42, 0x6c, 0x6f, 0x62, 0x47, 0x61, 0x73, 0x22, 0x9a, 0x01, 0x0a,
	0x11, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74,
	0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70,
	0x72, 0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x3e, 0x0a, 0x17, 0x73, 0x75, 0x67,
	0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70,
	0x69, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02,
	0x32, 0x30, 0x52, 0x15, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x46, 0x65, 0x65,
	0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x22, 0xf3, 0x01, 0x0a, 0x13, 0x50, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x56,
	0x32, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0a, 0x70, 0x72,
	0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x3e, 0x0a, 0x17, 0x73, 0x75, 0x67, 0x67,
	0x65, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69,
	0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32,
	0x30, 0x52, 0x15, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x46, 0x65, 0x65, 0x52,
	0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x55, 0x0a, 0x0b, 0x77, 0x69, 0x74, 0x68,
	0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
	0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x42, 0x13, 0x92,
	0xb5, 0x18, 0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x2e, 0x73, 0x69,
	0x7a, 0x65, 0x52, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x22,
	0xb4, 0x02, 0x0a, 0x13, 0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x41, 0x74, 0x74, 0x72, 0x69,
	0x62, 0x75, 0x74, 0x65, 0x73, 0x56, 0x33, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x27, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x72, 0x61,
	0x6e, 0x64, 0x61, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02,
	0x33, 0x32, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x76, 0x52, 0x61, 0x6e, 0x64, 0x61, 0x6f, 0x12, 0x3e,
	0x0a, 0x17, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x65, 0x5f,
	0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32, 0x30, 0x52, 0x15, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74,
	0x65, 0x64, 0x46, 0x65, 0x65, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x55,
	0x0a, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x2e, 0x65,
	0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x42, 0x13, 0x92, 0xb5, 0x18, 0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x61, 0x6c, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x0b, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72,
	0x61, 0x77, 0x61, 0x6c, 0x73, 0x12, 0x3f, 0x0a, 0x18, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x5f,
	0x62, 0x65, 0x61, 0x63, 0x6f, 0x6e, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x72, 0x6f, 0x6f,
	0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52,
	0x15, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x42, 0x65, 0x61, 0x63, 0x6f, 0x6e, 0x42, 0x6c, 0x6f,
	0x63, 0x6b, 0x52, 0x6f, 0x6f, 0x74, 0x22, 0x92, 0x02, 0x0a, 0x0d, 0x50, 0x61, 0x79, 0x6c, 0x6f,
	0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x40, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72,
	0x65, 0x75, 0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x32, 0x0a, 0x11, 0x6c, 0x61,
	0x74, 0x65, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x0f, 0x6c,
	0x61, 0x74, 0x65, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x48, 0x61, 0x73, 0x68, 0x12, 0x29,
	0x0a, 0x10, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x65, 0x72, 0x72,
	0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x60, 0x0a, 0x06, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00,
	0x12, 0x09, 0x0a, 0x05, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x49,
	0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x59, 0x4e, 0x43,
	0x49, 0x4e, 0x47, 0x10, 0x03, 0x12, 0x0c, 0x0a, 0x08, 0x41, 0x43, 0x43, 0x45, 0x50, 0x54, 0x45,
	0x44, 0x10, 0x04, 0x12, 0x16, 0x0a, 0x12, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x42,
	0x4c, 0x4f, 0x43, 0x4b, 0x5f, 0x48, 0x41, 0x53, 0x48, 0x10, 0x05, 0x22, 0xab, 0x01, 0x0a, 0x0f,
	0x46, 0x6f, 0x72, 0x6b, 0x63, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12,
	0x2e, 0x0a, 0x0f, 0x68, 0x65, 0x61, 0x64, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x0d, 0x68, 0x65, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x12,
	0x2e, 0x0a, 0x0f, 0x73, 0x61, 0x66, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x33, 0x32,
	0x52, 0x0d, 0x73, 0x61, 0x66, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x12,
	0x38, 0x0a, 0x14, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x5f, 0x62, 0x6c, 0x6f,
	0x63, 0x6b, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a,
	0xb5, 0x18, 0x02, 0x33, 0x32, 0x52, 0x12, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64,
	0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x61, 0x73, 0x68, 0x22, 0xd6, 0x01, 0x0a, 0x0a, 0x57, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x78,
	0x0a, 0x0f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x42, 0x4f, 0x82, 0xb5, 0x18, 0x4b, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x72, 0x79, 0x73, 0x6d, 0x61, 0x74, 0x69,
	0x63, 0x6c, 0x61, 0x62, 0x73, 0x2f, 0x70, 0x72, 0x79, 0x73, 0x6d, 0x2f, 0x76, 0x34, 0x2f, 0x63,
	0x6f, 0x6e, 0x73, 0x65, 0x6e, 0x73, 0x75, 0x73, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x70,
	0x72, 0x69, 0x6d, 0x69, 0x74, 0x69, 0x76, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61,
	0x74, 0x6f, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x52, 0x0e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61,
	0x74, 0x6f, 0x72, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x20, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x06, 0x8a, 0xb5, 0x18, 0x02, 0x32,
	0x30, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x22, 0xdd, 0x01, 0x0a, 0x0b, 0x42, 0x6c, 0x6f, 0x62, 0x73, 0x42, 0x75, 0x6e, 0x64,
	0x6c, 0x65, 0x12, 0x4e, 0x0a, 0x0f, 0x6b, 0x7a, 0x67, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x42, 0x25, 0x8a, 0xb5, 0x18,
	0x04, 0x3f, 0x2c, 0x34, 0x38, 0x92, 0xb5, 0x18, 0x19, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x6c, 0x6f,
	0x62, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x73, 0x69,
	0x7a, 0x65, 0x52, 0x0e, 0x6b, 0x7a, 0x67, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x6d, 0x65, 0x6e,
	0x74, 0x73, 0x12, 0x3d, 0x0a, 0x06, 0x70, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0c, 0x42, 0x25, 0x8a, 0xb5, 0x18, 0x04, 0x3f, 0x2c, 0x34, 0x38, 0x92, 0xb5, 0x18, 0x19,
	0x6d, 0x61, 0x78, 0x5f, 0x62, 0x6c, 0x6f, 0x62, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x6d,
	0x65, 0x6e, 0x74, 0x73, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x06, 0x70, 0x72, 0x6f, 0x6f, 0x66,
	0x73, 0x12, 0x3f, 0x0a, 0x05, 0x62, 0x6c, 0x6f, 0x62, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0c,
	0x42, 0x29, 0x8a, 0xb5, 0x18, 0x08, 0x3f, 0x2c, 0x31, 0x33, 0x31, 0x30, 0x37, 0x32, 0x92, 0xb5,
	0x18, 0x19, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x6c, 0x6f, 0x62, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x05, 0x62, 0x6c, 0x6f,
	0x62, 0x73, 0x22, 0x29, 0x0a, 0x04, 0x42, 0x6c, 0x6f, 0x62, 0x12, 0x21, 0x0a, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x0d, 0x8a, 0xb5, 0x18, 0x09, 0x62, 0x6c,
	0x6f, 0x62, 0x2e, 0x73, 0x69, 0x7a, 0x65, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22, 0x43, 0x0a,
	0x14, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c,
	0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x11, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74,
	0x65, 0x64, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x10, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x74, 0x68, 0x6f,
	0x64, 0x73, 0x42, 0xc6, 0x01, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x2e, 0x65, 0x74, 0x68, 0x65, 0x72,
	0x65, 0x75, 0x6d, 0x2e, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x76, 0x31, 0x42, 0x14, 0x45,
	0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x2c, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x65, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d,
	0x2f, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x65, 0x6e, 0x67, 0x69, 0x6e,
	0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x45, 0x45, 0x58, 0xaa, 0x02, 0x12, 0x45, 0x74, 0x68, 0x65,
	0x72, 0x65, 0x75, 0x6d, 0x2e, 0x45, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x56, 0x31, 0xca, 0x02,
	0x12, 0x45, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x5c, 0x45, 0x6e, 0x67, 0x69, 0x6e, 0x65,
	0x5c, 0x56, 0x31, 0xe2, 0x02, 0x1e, 0x45, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x5c, 0x45,
	0x6e, 0x67, 0x69, 0x6e, 0x65, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x14, 0x45, 0x74, 0x68, 0x65, 0x72, 0x65, 0x75, 0x6d, 0x3a,
	0x3a, 0x45, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_ethereum_engine_v1_execution_engine_proto_rawDescOnce sync.Once
	file_ethereum_engine_v1_execution_engine_proto_rawDescData = file_ethereum_engine_v1_execution_engine_proto_rawDesc
)

func file_ethereum_engine_v1_execution_engine_proto_rawDescGZIP() []byte {
	file_ethereum_engine_v1_execution_engine_proto_rawDescOnce.Do(func() {
		file_ethereum_engine_v1_execution_engine_proto_rawDescData = protoimpl.X.CompressGZIP(file_ethereum_engine_v1_execution_engine_proto_rawDescData)
	})
	return file_ethereum_engine_v1_execution_engine_proto_rawDescData
}

var file_ethereum_engine_v1_execution_engine_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_ethereum_engine_v1_execution_engine_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_ethereum_engine_v1_execution_engine_proto_goTypes = []interface{}{
	(PayloadStatus_Status)(0),                            // 0: ethereum.engine.v1.PayloadStatus.Status
	(*ExecutionPayload)(nil),                             // 1: ethereum.engine.v1.ExecutionPayload
	(*ExecutionPayloadBodyV1)(nil),                       // 2: ethereum.engine.v1.ExecutionPayloadBodyV1
	(*ExecutionPayloadCapella)(nil),                      // 3: ethereum.engine.v1.ExecutionPayloadCapella
	(*ExecutionPayloadDeneb)(nil),                        // 4: ethereum.engine.v1.ExecutionPayloadDeneb
	(*ExecutionPayloadCapellaWithValue)(nil),             // 5: ethereum.engine.v1.ExecutionPayloadCapellaWithValue
	(*ExecutionPayloadDenebWithValueAndBlobsBundle)(nil), // 6: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle
	(*ExecutionPayloadHeader)(nil),                       // 7: ethereum.engine.v1.ExecutionPayloadHeader
	(*ExecutionPayloadHeaderCapella)(nil),                // 8: ethereum.engine.v1.ExecutionPayloadHeaderCapella
	(*ExecutionPayloadHeaderDeneb)(nil),                  // 9: ethereum.engine.v1.ExecutionPayloadHeaderDeneb
	(*PayloadAttributes)(nil),                            // 10: ethereum.engine.v1.PayloadAttributes
	(*PayloadAttributesV2)(nil),                          // 11: ethereum.engine.v1.PayloadAttributesV2
	(*PayloadAttributesV3)(nil),                          // 12: ethereum.engine.v1.PayloadAttributesV3
	(*PayloadStatus)(nil),                                // 13: ethereum.engine.v1.PayloadStatus
	(*ForkchoiceState)(nil),                              // 14: ethereum.engine.v1.ForkchoiceState
	(*Withdrawal)(nil),                                   // 15: ethereum.engine.v1.Withdrawal
	(*BlobsBundle)(nil),                                  // 16: ethereum.engine.v1.BlobsBundle
	(*Blob)(nil),                                         // 17: ethereum.engine.v1.Blob
	(*ExchangeCapabilities)(nil),                         // 18: ethereum.engine.v1.ExchangeCapabilities
}
var file_ethereum_engine_v1_execution_engine_proto_depIdxs = []int32{
	15, // 0: ethereum.engine.v1.ExecutionPayloadBodyV1.withdrawals:type_name -> ethereum.engine.v1.Withdrawal
	15, // 1: ethereum.engine.v1.ExecutionPayloadCapella.withdrawals:type_name -> ethereum.engine.v1.Withdrawal
	15, // 2: ethereum.engine.v1.ExecutionPayloadDeneb.withdrawals:type_name -> ethereum.engine.v1.Withdrawal
	3,  // 3: ethereum.engine.v1.ExecutionPayloadCapellaWithValue.payload:type_name -> ethereum.engine.v1.ExecutionPayloadCapella
	4,  // 4: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.payload:type_name -> ethereum.engine.v1.ExecutionPayloadDeneb
	16, // 5: ethereum.engine.v1.ExecutionPayloadDenebWithValueAndBlobsBundle.blobs_bundle:type_name -> ethereum.engine.v1.BlobsBundle
	15, // 6: ethereum.engine.v1.PayloadAttributesV2.withdrawals:type_name -> ethereum.engine.v1.Withdrawal
	15, // 7: ethereum.engine.v1.PayloadAttributesV3.withdrawals:type_name -> ethereum.engine.v1.Withdrawal
	0,  // 8: ethereum.engine.v1.PayloadStatus.status:type_name -> ethereum.engine.v1.PayloadStatus.Status
	9,  // [9:9] is the sub-list for method output_type
	9,  // [9:9] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_ethereum_engine_v1_execution_engine_proto_init() }
func file_ethereum_engine_v1_execution_engine_proto_init() {
	if File_ethereum_engine_v1_execution_engine_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayload); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadBodyV1); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadCapella); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadDeneb); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadCapellaWithValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadDenebWithValueAndBlobsBundle); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadHeaderCapella); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecutionPayloadHeaderDeneb); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PayloadAttributes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PayloadAttributesV2); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PayloadAttributesV3); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PayloadStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ForkchoiceState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Withdrawal); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BlobsBundle); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Blob); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_ethereum_engine_v1_execution_engine_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExchangeCapabilities); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_ethereum_engine_v1_execution_engine_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ethereum_engine_v1_execution_engine_proto_goTypes,
		DependencyIndexes: file_ethereum_engine_v1_execution_engine_proto_depIdxs,
		EnumInfos:         file_ethereum_engine_v1_execution_engine_proto_enumTypes,
		MessageInfos:      file_ethereum_engine_v1_execution_engine_proto_msgTypes,
	}.Build()
	File_ethereum_engine_v1_execution_engine_proto = out.File
	file_ethereum_engine_v1_execution_engine_proto_rawDesc = nil
	file_ethereum_engine_v1_execution_engine_proto_goTypes = nil
	file_ethereum_engine_v1_execution_engine_proto_depIdxs = nil
}
